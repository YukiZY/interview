####22.Linux内核调度：
  * [linux内核调度机制](http://www.cppblog.com/baby-fly/archive/2011/01/27/139436.html)
  * [Linux内核进程调度以及定时器实现机制](http://www.cppblog.com/baby-fly/archive/2011/01/27/139436.html)
  * Linux的进程管理由进程控制块、进程调度、中断处理、任务队列、定时器、bottom half队列、系统调用、进程通信等等部分组成。
  
    * 1.进程控制块数据结构：
     所有进程（以PCB形式）组成一个双向列表。next_task和prev_task就是链表的前后向指针。链表的头尾都是init_task（init进程）。
     过进程还要根据其进程ID号插入到一个hash表当中，目的是加快进程搜索速度
     Linux系统的进程控制块用数据结构task_struct表示，这个数据结构占用1680个字节,进程运行状态包括如下几个：
     a.TASK_RUNNING  正在运行或在就绪队列run-queue中准备运行的进程，实际参与进程调度。
     b.TASK_INTERRUPTIBLE      处于等待队列中的进程，待资源有效时唤醒，也可由其它进程通过信号或定时中断唤醒后进入就绪队列run-queue。
     c.TASK_UNINTERRUPTIBLE 处于等待队列的进程，待资源有效时唤醒，不可由其它进程通过信号或者定时中断唤醒。
     d.TASK_ZOMBIE     表示进程结束但尚未消亡的一种状态（僵死），此时，进程已经结束运行并且已经释放了大部分资源，但是尚未释放进程控制块。
     e.TASK_STOPPED   进程暂停，通过其它进程的信号才能唤醒。
     
    * 2.进程调度：
     进程调度是由schedule()执行，其任务就是去run_queue队列中选取一个就绪态的进程
     进程调度分为【实时进程调度】和【非实时进程调度】，实时进程调度基于【动态优先级轮转法RR】和【先进先出算法FIFO】，
     非实时进程调度一律采用动态优先级轮转法RR，某个进程采用何种调度算法是根据进程控制块中数据结构task_struct的【policy属性】确定，
     其值主要为SCHED_RR/SCHED_FIFO(这两种为实时进程调度策略)/SCHED_OTHER(普通进程调度策略).
     用户进程的创建主要通过do_fork()实现，它是fork()系统调用的执行者，do_fork创建一个子进程，继承父进程的资源，初始化进程时钟、信号、时间等，
     完成子进程初始化后父进程将其挂到run_queue队列。子进程刚创建其状态为TASK_UNINTERRUPTIBLE,当初始化完成后被父进程唤醒置于TASK_RUNNING态，
     此时子进程进入就绪队列中等待调度
     如果进程采用轮转法，当时间片到时（10ms的整数倍），由时钟中断触发timer_interrupt( )函数引起新一轮的调度，把当前进程挂到就绪队列的尾部。
     获得CPU而正在运行的进程若申请不到某个资源，则调用sleep_on( )或interruptible_sleep_on( )睡眠，并进入就绪队列尾。
     状态为TASK_INTERRUPTIBLE的睡眠进程当它申请的资源有效时被唤醒，也可以由信号或者定时中断唤醒，唤醒以后进程状态变为TASK_RUNNING。
     
    * 3.进程上下文切换：
     它做的事只是保留正在运行进程的"环境"，并把将要运行的进程的"环境"加载上来，这个环境也叫上下文。它包括各个进程"公用"的东西，比如寄存器
     旧的进程环境保存在那，新的进程环境从那来，在i386上，有个tss段，是专用来保存进程运行环境的
     在Linux来说，在结构task_struct中有个类型为struct thread_struct的成员叫tss。
     因为Linux一般并不使用ldt，所以它们一般会指向一个共同的空的ldt段描述符，这样就可能不需要切换ldt了，如果进程next和prev是共享内存的话，
     那么页表的转换也就不必要了（这一般发生在clone时）
     
    * 4.系统调用：
     Linux系统调用的形式与POSIX兼容，也是一套C语言函数名的集合，如fork( )，read( )等等共221个。系统调用是通过INT 0x80软中断调用进入内核，
     然后根据系统调用号分门别类的进行服务。
     * 系统调用号：文件include/asm-i386/unistd.h为每一个系统调用规定了唯一的编号，这个编号与真正的响应函数之间的关系是利用系统调用号
     为数组的下标，可以在sys_call_table（系统调用表数组）中查找对应的响应函数的sys_name的入口地址。
     * 系统调用表：系统调用表sys_call_table是一组宏定义，将系统调用的编号和相应的内核系统调用处理函数的入口地址绑定。
     内核宏定义syscallN( )用于系统调用的格式转换和参数的传递。其中N取0～6之间的任意整数。参数个数为N的系统调用由syscallN负责格式
     转换和参数传递
     对系统调用的初始化，即是对INT 0x80的初始化。系统启动时，汇编子程序setup_idt准备了256项的idt表。设置0x80号软中断服务程序system_call，
     这个就是所有系统调用的总入口。
     当进程需要进行系统调用时，必须以C语言函数的形式写一句系统调用命令。
     该命令如果已经在某个头文件中由相应的syscallN( )展开，则用户程序必须包含该头文件。当进程执行到系统调用命令时，
     实际上执行的是syscallN( )展开的函数。系统调用的参数由寄存器传递，然后执行INT 0x80中断，以内核态进入入口地址system_call。
    * 5.
     
