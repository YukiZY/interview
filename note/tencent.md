 [腾讯后台面试题](http://blog.csdn.net/ibmfahsion/article/details/11992403?utm_source=tuicool&utm_medium=referral)

 [后端开发面试题](https://github.com/monklof/Back-End-Developer-Interview-Questions)

 [BAT面试题](https://github.com/kaiye/kaiye.github.com/issues/3)
 

####1.linux的文件描述符fd和文件指针flip:
>
  fd是一个整数，在调用open()时返回，起到一个索引的作用，进程通过PCB中的文件描述符表找到该fd所指向的文件指针filp
  文件描述符fd是open()返回的值,内核会在每个进程空间中维护一个文件描述符表表中有fd和flip对应关系，所有打开的文件都将通过此表中的fd
  来引用flip找到对应的文件而流(如: fopen)返回的是一个FILE结构指针,FILE结构是包含有文件描述符fd的，FILE结构可以看作是对fd直接操作
  的系统调用的封装, 它的优点是带有I/O缓存每个进程在PCB（ProcessControlBlock）即进程控制块中都保存着一份文件描述符表，
  表中有fd和flip的关联关系，fd就是这个表的索引，文件描述表中每个表项都有一个指向已打开文件的指针flip,打开的文件在内核中以file_struct的
  结构体表示，flip就指向文件文件结构体。    
  [open()和fopen()的差别](http://blog.csdn.net/hairetz/article/details/4150193)

####2.共享内存:
>
  共享内存是最快的IPC(进程间通信)方式，它允许多个不相关的进程去访问同一片物理内存，共享内存是由IPC分配的一段地址空间，
  所有共享这段地址的进程都可以把这段地址加入到自己进程的地址空间段中，所有的进程就可以同时访问这块内存地址，
  如果一个进程对这段地址的数据了改动，那么其他进程来读取这段地址就可以看到数据的改变，因此共享内存对于共享数据的传输是非常高效的    
  共享内存原理：共享内存是最有用的进程间通信方式之一，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间中的不同的逻辑地址上。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。

####3.ELF：
>
__inux Excutable and Linktable Format,ELF标准作为工作在32位INTEL体系上不同操作系统之间可移植的二进制文件格式__

####4.C++进程内存空间分布：
[linux虚拟地址空间分配](http://www.cnblogs.com/clover-toeic/p/3754433.html)
>
  * __linux系统中一个进程占用的最大空间为2的32次方=4G，即一个进程有4G的虚拟内存空间,其中1G为内核空间，3G为用户空间__
  * __用户空间中从高到低依次是 《栈stack->内存映射区memory mapping->堆heap->未初始化数据区BSS->数据区data->代码区code》__
  * __内存映射区memory mapping：共享内存就在内存映射区，动态链接库也会被映射到这里__
  * __栈空间：栈地址从高到低分配，栈顶地址和栈大小固定2M，常量区也在栈空间上，存储局部,临时变量,在程序块开始时自动分配内存,结束时自动释放内存.存储函数的返回指针. 当函数被调用时，它们被压入栈；当函数返回时，它们就要被弹出堆栈。__
  * __堆空间：链表形式，有效的虚拟内存空间，最大3G，分配的堆内存是经过字节对齐的空间，以适合原子操作。堆管理器通过链表管理每个申请的内存，由于堆申请和释放是无序的，最终会产生内存碎片。堆内存一般由应用程序分配释放，回收的内存可供重新使用。若程序员不释放，程序结束时操作系统可能会自动回收__
  * __BSS段：可执行程序分为BSS段，数据段，代码段(文本段)；__
  __在C++中BSS(Block Started by Symbol)是指用来存放未初始化,静态变量和全局变量的内存段，是可读写的内存，特点是在程序运行之前BSS会自动清0，这就是为什么c++中未初始化的静态变量和全局变量会默认为0的原因__
  * __初始化的静态变量和全局变量、成员变量、临时变量都是存放在数据段中__
  * __程序段（text）:  程序段为程序代码在内存中的映射.一个程序可以在内存中多有个副本.__
  * __文字常量区: 常量字符串就是放在这里的。__

  * __3和4称为静态存储区，6和7称为动态存储区__
    __size a.out可以查看可执行文件的段大小__
    
          //main.cpp 
          int a = 0; 全局初始化区--data区 
          char *p1; 全局未初始化区--BSS区
          main() 
          { 
          int b; 栈--statck
          char s[] = "abc"; 栈--stack "abc"--数据段data
          char *p2; 栈--stack 
          char *p3 = "123456"; 123456\0在常量区，p3在栈上-stack。 
          static int c =0； 全局（静态）初始化区--data区
          p1 = (char *)malloc(10);--堆heap 
          p2 = (char *)malloc(20);--堆heap
          分配得来得10和20字节的区域就在堆区。 
          strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
          }

####5.makefile编写：
          makedir mf
          cd mf
          vim makefile.mk
          hello.o:hello.c hello.h
            gcc -c hello.o -Lm
          make  
          ./hello
          预处理-----> 编译 ----> 汇编 ----> 链接 
          #gcc -E hello.c -o hello.i
          #gcc –S hello.i –o hello.s 
          #gcc –c hello.s –o hello.o 
          #gcc hello.o –o hello.exe 
          #./hello.exe
  
####6.GDB:
>
 GNU debugger 安装GDB之后，在生成执行文件时加上-g   如：gcc -g -o hello hello.c
  list / info / break / file / continue / run / step / display / run / quit

####7.静态链接和动态链接：
>
  * 动态链接是指在生成可执行文件时不将所有程序用到的函数链接到一个文件，因为有许多函数在操作系统带的dll文件中，当程序运行时直接从操作系统中，而静态链接就是把所有用到的函数全部链接到exe文件中。
  * 动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了

####8.多进程和多线程的差异比较：
>

          维度               |       多进程                                        |         多线程                   
         数据共享同步        | 进程间数据是独享的，共享复杂，需要IPC，同步简单     | 多线程共享进程数据，共享简单，同步复杂
         内存/CPU            | 进程占用内存大，切换复杂，CPU利用率低               | 线程内存占用少，切换简单，CPU利用率高
         创建、销毁、切换    | 创建、切换、销毁复杂，速度慢                        | 比较简单，速度快
         编程、调试          | 简单                                                | 复杂
         可靠性              | 进程间不会相互影响                                  | 一个线程挂掉导致整个进程的所有线程都挂掉
         分布式              | 适合多核、多机分布                                  | 适用于多核分布
 
__线程私有的东西：线程ID，一组寄存器，栈，调度优先级和策略，线程私有数据__     
[线程私有数据](http://blog.chinaunix.net/uid-8917757-id-2450452.html)   __一个线程真正拥有的唯一私有存储是处理器寄存器__
 
####9.线程和进程：
>
  * 进程——资源分配的最小单位，线程——程序执行的最小单位
   * 一般运行一个程序就是一个进程
   * 进程可以创建一个线程，也可以创建一个进程
   * 线程是由进程管理，线程之间、线程与父进程之后可以共享内存变量
   *  进程之间一般不可以直接共享内存变量，需要使用一些进程间的控制共享内存变量
   * 进程是个容器或者说资源管理者，有独立的内存地址空间。
   * 线程依赖于它所在的进程，共享进程的资源和内存地址空间
  * 应用场景：
   * 需要频繁创建销毁的优先使用线程
   * 需要进行大量计算的有限使用线程，大量计算就意味着需要频繁切换cpu和对cpu的大量消耗
   * 强相关的处理用线程，弱相关的处理用进程
   * 涉及到多机分布的用进程，涉及到多核分布的用线程
   * 一个进程的开销大约是一个线程开销的30倍左右  
  * [进程、线程、多线程](http://www.cnblogs.com/obama/archive/2013/04/12/3016509.html)

####10.线程同步与互:
>
  * 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没得到另一个线程的消息时应等待，直到消息到达时才被唤。
  * 互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步
  
####11.进程间通信机制：
>
  * __消息队列__：
  * __socket套接字__：
  * __共享内存__：
  * __信号量__：
  * __信号__：
  * __管道__：
  
####12.VxWorks相关：
>
  VxWorks是单进程多线程的系统，多任务类似于多线程，一个进程用于申请内存空间和系统资源，任务之间实现内存和资源的共享
  * __二进制信号量__：最常用的，主要用于互斥和同步
  * __互斥信号量__：二进制的特殊情况，主要用于优先级继承、安全删除、递归等
  * __计数信号量__：主要用于保护一个资源的多个实例

####13.TCP和UDP:
>
  * __面向连接__：TCP是面向连接的，面向连接意味着两个TCP应用在使用之前需要通过3次握手建立一个TCP链接，在一个TCP只有两方彼此通信，多播和广播不能用于TCP；UDP不需要面向连接的，因此在传输之后不需要经过握手，直接发送数据即可，因此可以使用与多播和广播
  * __可靠性__：TCP通过端到端的流量控制，对收到的数据包进行确认，采用超时重发，对失序的数据进行重新排序的机制以保证数据的可靠性，UDP是不可靠的传输，接收方可能会收不到发送方的报文
  * __传输模式__：TCP是字节流模式协议，UDP是数据报模式协议，TCP应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系，进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报
  * __效率上__：速度上，一般TCP速度慢，传输过程中需要对数据进行确认，超时重发，还要对数据进行排序；UDP没有这些机制所以速度快，数据比例，TCP头至少20个字节，UDP头8个字节，相对效率高
  * __用途上__：用于TCP可靠性，http，ftp使用。而由于UDP速度快，视频，在线游戏多用UDP，保证实时性
  
