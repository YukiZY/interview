###1.用户态与内核态：
* Intel x86架构的CPU来说一共有0~3四个特权级，__0级最高，3级最低__，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查
  对于Unix/Linux来说，__只使用了0级特权级和3级特权级__。也就是说在Unix/Linux系统中，一条工作在0级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力，__当程序运行在3级特权级上时，就可以称之为运行在用户态__，
  因为这是最低特级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，__当程序运行在0级特权级上时__,
  __就可以称之为运行在内核态用户态切换__

* 内核态调用的3中方式：
  __系统函数调用(主动)，异常（被动），外围设备中断(被动)__ 。触发方式上看，可以认为存在前述3种不同的类型。

>
但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，
因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的

###2.linux的exit()和_exit():
* 调用exit()或者_exit(),系统都会无条件的停止所有操作，清除包括PCB在内的各种数据结构、资源、内存，并终止本进程的运行。
* linux中退出一个进程的方式分为__正常退出__和__异常退出__，但不管哪种退出，都会调用内核中同一段代码关闭进程所有已打开的
  文件描述符fd、释放内存和资源
* __正常退出__：在main中调用return或者调用exit()/_exit()；
* __异常退出__：调用abort函数或者收到某个信号，该信号导致程序终止；

* __区别__：
 * a.两个函数所在的头文件不一样，exit是stdlib.h、_exit()是unistd.h
 * b._exit()会终止进程，但不关闭文件，不清除输出缓存，也不调用出口函数；exit函数将终止调用进程。在退出程序之前，所有文件关闭，
    缓冲输出内容将刷新定义，并调用所有已刷新的“出口函数”
 * c.exit()是系统调用_exit()的封装，exit()在调用exit系统会检查文件的打开情况，将文件缓冲区的内容全部写入文件在关闭，
    而_exit()会直接关闭进程，导致文件缓冲区中的数据丢失，一次要保证数据的完整性就一定要调用exit()
  
###3.linux文件读写的“缓冲I/O”：
* Linux的标准函数库中，有一种被称作“缓冲I/O”的操作，其特征就是对应每一个打开的文件，在内存中都有一片缓冲区。  
  每次读文件时，会连续的读出若干条记录，这样在下次读文件时就可以直接从内存的缓冲区读取；   
  同样，每次写文件的时候也仅仅是写入内存的缓冲区，等满足了一定的条件（如达到了一定数量或遇到特定字符等），  
  再将缓冲区中的内容一次性写入文件。这种技术大大增加了文件读写的速度，但也给编程代来了一点儿麻烦    
  
###4.静态链接和动态链接：
>
  * 动态链接是指在生成可执行文件时不将所有程序用到的函数链接到一个文件，因为有许多函数在操作系统带的dll文件中，当程序运行时直接从操作系统中，而静态链接就是把所有用到的函数全部链接到exe文件中。
  * 动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了

###5.VxWorks相关：
>
  VxWorks是单进程多线程的系统，多任务类似于多线程，一个进程用于申请内存空间和系统资源，任务之间实现内存和资源的共享
  * __二进制信号量__：最常用的，主要用于互斥和同步
  * __互斥信号量__：二进制的特殊情况，主要用于优先级继承、安全删除、递归等
  * __计数信号量__：主要用于保护一个资源的多个实例
  
###6.[守护进程](http://www.cnblogs.com/mickole/p/3188321.html)：
Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。
它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务    

常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等   

守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，
因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源    

一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。
守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。    

编写守护进程的一般步骤步骤：  

（1）在父进程中执行fork并exit推出；   

（2）在子进程中调用setsid函数(建立一个会话期)创建新的会话；   

（3）在子进程中调用chdir函数，让根目录 ”/” 成为子进程的工作目录；   

（4）在子进程中调用umask函数(设置权限)，设置进程的umask为0；   

（5）在子进程中关闭任何不需要的文件描述符   
