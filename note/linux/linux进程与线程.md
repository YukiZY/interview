
####1.C++进程内存空间分布：
[linux虚拟地址空间分配](http://www.cnblogs.com/clover-toeic/p/3754433.html)
  * linux系统中一个进程占用的最大空间为2的32次方=4G，即一个进程有4G的虚拟内存空间,其中1G为内核空间，3G为用户空间
  * 用户空间中从高到低依次是 《栈stack->内存映射区memory mapping->堆heap->未初始化数据区BSS->数据区data->代码区code》
  * 内存映射区memory mapping：共享内存就在内存映射区，动态链接库也会被映射到这里
  * 栈空间：栈地址从高到低分配，栈顶地址和栈大小固定2M，常量区也在栈空间上，存储局部,临时变量,在程序块开始时自动分配内存,结束时自动释放内存.存储函数的返回指针. 当函数被调用时，它们被压入栈；当函数返回时，它们就要被弹出堆栈。
  * 堆空间：链表形式，有效的虚拟内存空间，最大3G，分配的堆内存是经过字节对齐的空间，以适合原子操作。堆管理器通过链表管理每个申请的内存，由于堆申请和释放是无序的，最终会产生内存碎片。堆内存一般由应用程序分配释放，回收的内存可供重新使用。若程序员不释放，程序结束时操作系统可能会自动回收
  * BSS段：可执行程序分为BSS段，数据段，代码段(文本段)；
  在C++中BSS(Block Started by Symbol)是指用来存放未初始化,静态变量和全局变量的内存段，是可读写的内存，特点是在程序运行之前BSS会自动清0，这就是为什么c++中未初始化的静态变量和全局变量会默认为0的原因
  * 初始化的静态变量和全局变量、成员变量、临时变量都是存放在数据段中
  * 程序段（text）:  程序段为程序代码在内存中的映射.一个程序可以在内存中多有个副本.
  * 文字常量区: 常量字符串就是放在这里的。
  * 3和4称为静态存储区，6和7称为动态存储区   size a.out可以查看可执行文件的段大小
    
          //main.cpp 
          int a = 0; 全局初始化区--data区 
          char *p1; 全局未初始化区--BSS区
          main() 
          { 
          int b; 栈--statck
          char s[] = "abc"; 栈--stack "abc"--数据段data
          char *p2; 栈--stack 
          char *p3 = "123456"; 123456\0在常量区，p3在栈上-stack。 
          static int c =0； 全局（静态）初始化区--data区
          p1 = (char *)malloc(10);--堆heap 
          p2 = (char *)malloc(20);--堆heap
          分配得来得10和20字节的区域就在堆区。 
          strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
          }
          
####2.多进程和多线程的差异比较：

          维度               |       多进程                                        |         多线程                   
         数据共享同步        | 进程间数据是独享的，共享复杂，需要IPC，同步简单     | 多线程共享进程数据，共享简单，同步复杂
         内存/CPU            | 进程占用内存大，切换复杂，CPU利用率低               | 线程内存占用少，切换简单，CPU利用率高
         创建、销毁、切换    | 创建、切换、销毁复杂，速度慢                        | 比较简单，速度快
         编程、调试          | 简单                                                | 复杂
         可靠性              | 进程间不会相互影响                                  | 一个线程挂掉导致整个进程的所有线程都挂掉
         分布式              | 适合多核、多机分布                                  | 适用于多核分布
 
[线程私有的东西](http://blog.chinaunix.net/uid-8917757-id-2450452.html):       
__线程ID，一组处理器寄存器，栈，调度优先级和策略，线程私有数据__     

####3.线程和进程对比：
  * 进程——资源分配的最小单位，线程——程序执行的最小单位
   * 一般运行一个程序就是一个进程
   * 进程可以创建一个线程，也可以创建一个进程
   * 线程是由进程管理，线程之间、线程与父进程之后可以共享内存变量
   *  进程之间一般不可以直接共享内存变量，需要使用一些进程间的控制共享内存变量
   * 进程是个容器或者说资源管理者，有独立的内存地址空间。
   * 线程依赖于它所在的进程，共享进程的资源和内存地址空间
  * 应用场景：
   * 需要频繁创建销毁的优先使用线程
   
    > 
     实例：web服务器。来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。

   * 需要进行大量计算的有限使用线程，大量计算就意味着需要频繁切换cpu和对cpu的大量消耗
    
    >
     实例：图像处理、算法处理

   * 强相关的处理用线程，弱相关的处理用进程
    
    >
     实例：一般的server需要完成如下任务：消息收发和消息处理。消息收发和消息处理就是弱相关的任务，而消息处理里面可能又分为消息解码、业务处理，这两个任务相对来说相关性就要强多了。因此消息收发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计。   

   * 涉及到多机分布的用进程，涉及到多核分布的用线程
   * 一个进程的开销大约是一个线程开销的30倍左右  
  * [进程、线程、多线程](http://www.cnblogs.com/obama/archive/2013/04/12/3016509.html)
 
####4.概念
一般运行一个程序称为一个进程。

进程可以创建线程，也可以创建进程。

线程是由进程管理的，线程之间、线程和父进程（创建线程的进程）之间可以共享内存变量（需要使用策略的）。

进程之间一般不可以直接共享内存变量，需要使用一些进程间的控制共享内存变量。

如果你使用并行计算，建议使用线程。

进程是个容器或者说资源管理者，有独立的内存地址空间。
线程依赖于它所在的进程，共享进程的资源和内存地址空间。

unix特别是linux里面，线程与进程接近；    
Linux下的进程与线程比较相近。这么说的一个原因是它们都需要相同的数据结构来表示，即task_struct。     
区别在于一个有独立的用户空间，一个是共享的用户空间。    
windows的进程完全是个容器，线程更轻量级。    

####5.fork()和clone()异同：
Linux的用户进程不能直接被创建出来，因为不存在这样的API。    
它只能从某个进程中复制出来，再通过exec这样的API来切换到实际想要运行的程序文件。    
复制的API包括三种：fork、clone、vfork。三个函数底层实现都是do_fork().但是传入参数不一样
* fork():    
 fork()是进程资源的完全复制，包括进程PCB，进程的系统堆栈，进程的用户空间，进程打开的设备，用户空间比较大，采用"cooy-on-write"机制.
 复制出来的子进程有自己的task_struct结构和pid   
 fork()调用执行一次返回两个值，对于父进程，fork函数返回子程序的进程号，而对于子程序，fork函数则返回零，这是一个函数返回两次的本质
 __fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法__

 >
  fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只
 有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），
 子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改
 相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有
 各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进
 程的代码段也会分配单独的物理空间。

* clone():
 clone()是半复制，只复制进程PCB和进程系统堆栈，进程的地址空间和进程打开的设备都是与父进程完全共享   
 clone()是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享   
 __clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止__

* vfork():    
 用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。    Vfork也是在父进程中返回子进程的进程号，在子进程中返回0   
 用vfork()创建的子进程必须显示调用exit()来结束，否则子进程将不能结束    
__vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制__


