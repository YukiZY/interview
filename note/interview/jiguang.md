####1.read/write和fread/fwrite有什么区别？

fread就是通过read来实现的，fread是C语言的库，而read是系统调用。
差别在read每次读的数据是调用者要求的大小，比如调用者要求读取10个字节数据，read就会从内核缓冲区（操作系统开辟的一段空间用来存储磁盘上的数据）读10个字节数据到数组中，所以每次调用read会涉及到用户态与內核态之间的切换从而损耗一定的性能。而fread不一样，为了加快读的速度，fread每次都会从内核缓冲区读比要求更多的数据，然后放到应用进程缓冲区(首地址存在FILE结构体中)，这样下次再读数据只需要到应用进程缓冲区中去取而无需过多的系统调用。

 fwrite也是通过write来实现的，fwrite是C语言的库，而write是系统调用。
差别在write每次写的数据是调用者要求的大小，比如调用者要求写入10个字节数据，write就会写10个字节数据到内核缓冲区中，所以依然涉及到用户态与內核态之间的切换，操作系统会定期地把这些存在内核缓冲区的数据写回磁盘中。而fwrite不一样，fwrite每次都会先把数据写入一个应用进程缓冲区，等到该缓冲区满了，或者调用类似调用fflush这种冲洗缓冲区的函数时，系统会调用write一次性把相应数据写进内核缓冲区中。同样减少了系统调用(即write调用)。

所以我们应该知道，实际上write和read不会直接从磁盘文件中读写数据。例如read是从磁盘所关联的一个内核缓冲区读写数据。(因为磁盘读取数据速度实在太慢了，所以操作系统往往采用预读技术读取磁盘数据)。write也是仅将数据写进内核缓冲区，操作系统通过运行一个守护进程，定期的将内核缓冲区写入磁盘。

####2.vector和list的原理，list怎么计算节点个数，内部实现什么是？

vector采用连续内存，list采用环状双向链表，gcc中的SGI STL中的list.size()采用的是循环遍历计算节点，VC++中的STL的list.size()使用计数方式。

####3.一亿个int数据中，找出前100大的数据

1亿int数据的大小是400M大小，可以直接加载进入内存，然后取前100个数据构造一个小顶堆，然后顺序读取从100位置开始的每一个数据与堆顶数据比较，如果比堆顶数据大，那么和堆顶数据对换，然后堆重新进行调整，否则就直接比较下一个数据。
