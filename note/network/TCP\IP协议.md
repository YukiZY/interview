###1.TCP和UDP异同：
* __面向连接__：TCP是面向连接的，面向连接意味着两个TCP应用在使用之前需要通过3次握手建立一个TCP链接，在一个TCP只有两方彼此通信，
多播和广播不能用于TCP；UDP不需要面向连接的，因此在传输之后不需要经过握手，直接发送数据即可，因此可以使用与多播和广播

* __可靠性__：TCP通过端到端的流量控制，对收到的数据包进行确认，采用超时重发，对失序的数据进行重新排序的机制以保证数据的可靠性，
UDP是不可靠的传输，接收方可能会收不到发送方的报文

* __传输模式__：TCP是字节流模式协议，UDP是数据报模式协议，TCP应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系，
进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报

* __效率上__：速度上，一般TCP速度慢，传输过程中需要对数据进行确认，超时重发，还要对数据进行排序；UDP没有这些机制所以速度快，
数据比例，TCP头至少20个字节，UDP头8个字节，相对效率高

* __用途上__：用于TCP可靠性，http，ftp使用。而由于UDP速度快，视频，在线游戏多用UDP，保证实时性

###2.TCP三次握手：
* __第一次握手__：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 
* __第二次握手__：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），
  即SYN+ACK包，此时服务器进入SYN_RECV状态；
* __第三次握手__：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，
  完成三次握手。 
* 完成三次握手，客户端与服务器开始传送数据.

###[3.TCP协议](http://blog.csdn.net/dog250/article/details/6612496)：
确切的说，TCP协议有两重身份，作为网络协议，它弥补了IP协议尽力而为服务的不足，实现了有连接，可靠传输，报文按序到达。作为一个主机软件，
它和UDP以及左右的传输层协议隔离了主机服务和网络，它们可以被看做是一个多路复用/解复用器，将诸多的主机进程数据复用/解复用到IP层。   
作为网络协议,和对端的TCP接口，实现TCP的控制逻辑，作为多路复用/解复用器，和下层IP协议接口，实现协议栈功能。   
TCP要点有四，__一曰有连接，二曰可靠传输，三曰数据按照到达，四曰端到端流量控制__

IP层的作用有两点:地址管理，路由选择；IP层是没有方向的，只靠路由寻址,因此TCP被设计为有链接，这样就可以保证数据传输

* __有链接:__       　　　
TCP基本，被设计成基于流的协议，TCP需要先建立链接，后续传输多少数据无所谓，只要是统一链接的数据能识别出来即可。

 * 疑难１：[３次握手和４次挥手](http://blog.csdn.net/whuslei/article/details/6667471/)：
  
  > 
  通过３次握手建立一条链接，该握手初始化了传输可靠性和顺序性的必要信息，这些信息包括两边的初始序列号，初始序列号生确认号，
  该３次握手实际上并不一定是必须单独传输的，完全可以和数据一起传输　
  >
  通过４次挥手拆除一条链接，因为链接是全双工的，所以必须单独拆除每一条链接，拆除链接比建立链接复杂，意义是不一样的，３次
  握手的目的很简单，就是分配资源，初始化序列号；而４次挥手的目的是终止数据传输，回收资源，此时两个站点两边的序列号已经无
  关系，必须等待两方都没有数据传输时才能断开链接，因此必须在两个方向都关闭，所以至少需要４次。

 * 疑难２：TIME_WAIT状态：
 
  >
  1.虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。
  所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。
  >
  2.假如没有TIME_WAIT状态，那么在第一次链接结束之后，ACK报文发送出去，但是还在链路上，没有到达对端，此时第二个链接用了
  相同的５元祖（SIP/DIP/TCP/SPORT/DPORT）建立了链接，此时第一个链接的ACK报文到达，第二个链接以为是要断开链接，这就会导致
  数据还未发送就关闭，虽然是低概率事件，但确实有可能发生。
  
 * 疑难３：重用一个链接和重用一个套接字：
  
  >
   单独重用一个套接字是没有问题的，但是重用一个链接就有可能出现TIME_WAIT上的错误，５元祖标示一个链接，而不是一个套接字。
　 套接字和链接差异：比如一个server可以和ｎ个client链接，一个server与一个client之间是建立一个链接，但是一个server用一个套接字
　
* __传输可靠性:__　
 传输可靠性性就是通过确认号实现的，发送端发送一个分段之后，接下来接收端就要发送一个确认，发送端收到确认后才发送下一个分段
 这就是所谓的“停止－等待”协议。不过TCP采用了滑窗机制使得每一次发送的数据量大小不确定。这种场景就存在一个可能确认报文没有
 收到的情况，有可能时确认报文丢失导致一直等待下去，有可能是报文还在链路上未到达导致数据多发。因此要解决确认号等待时间

 * 疑难４：超时时间计算：
  
  >
  除了考虑每两次测量值的偏差之外，其变化率也应该考虑在内，如果变化率过大，则通过以变化率为自变量的函数为主计算RTT(如果陡然
  增大，则取值为比较大的正数，如果陡然减小，则取值为比较小的负数，然后和平均值加权求和)，反之如果变化率很小，则取测量平均值

 * 疑难５：超时计时器管理--每个链接一个超时计时器:
  
  >
  采用每一个TCP分段一个计时器的，管理方便，但是对内存和调度开销太大，因此默认都采用一个链接一个计时器。    
  a.发送TCP分段时，如果还没有重传定时器开启，那么开启它。   
  b.发送TCP分段时，如果已经有重传定时器开启，不再开启它。   

 * 疑难６：如何测量RTT:

  >
  目前很多TCP实现了时间戳，这样就方便多了，发送端再也不需要保存发送分段的时间了，只需要将其放入协议头的时间戳字段，然后接收
  端将其回显在ACK即可，然后发送端收到ACK后，取出时间戳，和当前时间做算术差，即可完成一次RTT的测量。
  
* __数据顺序性：__
 * 疑难7: 乱序数据缓存和选择确认：
  
  >
  RFC建议如果内存允许，还是要缓存这些乱序到来的分段，然后实现一种机制等到可以拼接成一个按序序列的时候将缓存的分段拼接，这就类似于IP协议中的分片一样    
  现在，TCP实现了一种称为选择确认的方式，接收端会显式告诉发送端需要重传哪些分段而不需要重传哪些分段。这无疑避免了重传风暴

* __端到端流量控制:__      
 端到端的流量控制使用滑动窗口来实现。滑动窗口的原理非常简单，基本就是一个生产者/消费者模型   

 * 疑难８：糊涂窗口综合征：

  >
  此时接收窗口已然被填满，慢速的应用程序慢腾腾的读取了一个字节，空出一个位置，然后通告给TCP的发送端，发送端得知空出一个位置，马上发出一个字节，又将接收端填满，然后接收应用程序又一次慢腾腾..     
  这个问题极大的浪费了网络带宽，降低了网络利用率
  
 * 疑难９：糊涂窗口解决方法－窗口通告：
 
  >
  因此可以限制接收端当窗口为0时，直接通告给发送端以阻止其继续发送数据，只有当其接收窗口再次达到MSS的一半大小的时候才通告一
  个不为0的窗口，此前对于所有的发送端的窗口probe分段(用于探测接收端窗口大小的probe分段，由TCP标准规定)，全部通告窗口为0，
  这样发送端在收到窗口不为0的通告，那么肯定是一个比较大的窗口，因此发送端可以一次性发出一个很大的TCP分段，包含大量数据
  
###4.[UDP协议:](http://blog.csdn.net/dog250/article/details/6896949)
* UDP的无连接性已经深入人心，协议上的无连接性指的是一个UDP的Endpoint1(IP,PORT)，可以向多个UDP的Endpointi(IP,PORT)发送数据包，也可以接收来自多个UDP的Endpointi(IP,PORT)的数据包。

* 实现上，需要考虑这样一个特殊情况：UDP Client 在Endpoint_C1只往UDP Server的Endpoint_S1发送数据包，
并且只接收来自Endpoint_S1的数据包，把UDP通信双方都固定下来，这样不就形成一条单向的虚”连接”了么？

* __send()__:
 如果一个UDP是connect的，那就可以在connect之后直接调用send了，内核在应用connect之后就永久维护了这次UDP的连接，以后每次收
 发数据，内核不再需要分配/删除这些数据，而只是查找就可以了，同时也减少了数据的拷贝量，既然connect的UDP在内核中已经存在了
 一个“连接”，那么无论何时，只要通信没有结束，内核总是能随时追踪到这个“连接”    
 
* __sendto()__:
  如果使用sendto，需要拷贝的参数就会多一些，参数到了内核空间之后，内核还要准备数据结构暂时容纳这些参数，当数据发出之后，
  内核需要释放这些暂时存储的参数(当然可以使用栈来管理这些参数以实现自动释放)。    

* __ 最后说明一点，UDP的连接是单向的，在调用connect的时候并不会产生任何通信流量，它只是在内核协议栈中绑定了一对五元组而已，
  该五元组是：UDP协议/源IP/源端口/目的IP/目的端口。__

* 有的时候，真的需要这样的“发后不管，尽力而为”的服务，TCP/IP的绝妙解决方式不是直接让IP来提供这个服务，而是在IP之上提供了
  多路复用的UDP，结果是，针对于主机，同一个IP可以承载多个“发后不管，尽力而为”的服务，IP最终仅仅提供传输服务。

 > 
  1.你的应用完全是udp完成，或者你不在乎tcp会受到的影响     
  2.你对网络状态很熟悉，确保udp网络中没有氓流行为，疯狂抢带宽    
  3.通信双方配置，负载匹配或者自己手工解决了这些问题    
  4.数据事实证明TCP真的比UDP更低效率或者你宗教般痴迷于UDP的高效率    
  5.你不在乎上述4点或者你根本不懂网络    
  6.TCP实在不方便实现多点传输的情况
