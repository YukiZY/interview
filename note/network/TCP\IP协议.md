###1.TCP和UDP异同：
* __面向连接__：TCP是面向连接的，面向连接意味着两个TCP应用在使用之前需要通过3次握手建立一个TCP链接，在一个TCP只有两方彼此通信，
多播和广播不能用于TCP；UDP不需要面向连接的，因此在传输之后不需要经过握手，直接发送数据即可，因此可以使用与多播和广播

* __可靠性__：TCP通过端到端的流量控制，对收到的数据包进行确认，采用超时重发，对失序的数据进行重新排序的机制以保证数据的可靠性，
UDP是不可靠的传输，接收方可能会收不到发送方的报文

* __传输模式__：TCP是字节流模式协议，UDP是数据报模式协议，TCP应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系，
进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报

* __效率上__：速度上，一般TCP速度慢，传输过程中需要对数据进行确认，超时重发，还要对数据进行排序；UDP没有这些机制所以速度快，
数据比例，TCP头至少20个字节，UDP头8个字节，相对效率高

* __用途上__：用于TCP可靠性，http，ftp使用。而由于UDP速度快，视频，在线游戏多用UDP，保证实时性

###2.TCP三次握手：
* __第一次握手__：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 
* __第二次握手__：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），
  即SYN+ACK包，此时服务器进入SYN_RECV状态；
* __第三次握手__：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，
  完成三次握手。 
* 完成三次握手，客户端与服务器开始传送数据.

###3.TCP协议：
确切的说，TCP协议有两重身份，作为网络协议，它弥补了IP协议尽力而为服务的不足，实现了有连接，可靠传输，报文按序到达。作为一个主机软件，
它和UDP以及左右的传输层协议隔离了主机服务和网络，它们可以被看做是一个多路复用/解复用器，将诸多的主机进程数据复用/解复用到IP层。   
作为网络协议,和对端的TCP接口，实现TCP的控制逻辑，作为多路复用/解复用器，和下层IP协议接口，实现协议栈功能。   
TCP要点有四，__一曰有连接，二曰可靠传输，三曰数据按照到达，四曰端到端流量控制__

IP层的作用有两点:地址管理，路由选择；IP层是没有方向的，只靠路由寻址,因此TCP被设计为有链接，这样就可以保证数据传输

* __有链接:__       　　　
TCP基本，被设计成基于流的协议，TCP需要先建立链接，后续传输多少数据无所谓，只要是统一链接的数据能识别出来即可。

 * 疑难１：[３次握手和４次挥手](http://blog.csdn.net/whuslei/article/details/6667471/)：
  
  > 
  通过３次握手建立一条链接，该握手初始化了传输可靠性和顺序性的必要信息，这些信息包括两边的初始序列号，初始序列号生确认号，
  该３次握手实际上并不一定是必须单独传输的，完全可以和数据一起传输　
  >
  通过４次挥手拆除一条链接，因为链接是全双工的，所以必须单独拆除每一条链接，拆除链接比建立链接复杂，意义是不一样的，３次
  握手的目的很简单，就是分配资源，初始化序列号；而４次挥手的目的是终止数据传输，回收资源，此时两个站点两边的序列号已经无
  关系，必须等待两方都没有数据传输时才能断开链接，因此必须在两个方向都关闭，所以至少需要４次。

 * 疑难２：TIME_WAIT状态：
 
  >
  1.虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。
  所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。
  >
  2.假如没有TIME_WAIT状态，那么在第一次链接结束之后，ACK报文发送出去，但是还在链路上，没有到达对端，此时第二个链接用了
  相同的５元祖（SIP/DIP/TCP/SPORT/DPORT）建立了链接，此时第一个链接的ACK报文到达，第二个链接以为是要断开链接，这就会导致
  数据还未发送就关闭，虽然是低概率事件，但确实有可能发生。
  
 * 疑难３：重用一个链接和重用一个套接字：
 　
　>
  单独重用一个套接字是没有问题的，但是重用一个链接就有可能出现TIME_WAIT上的错误，５元祖标示一个链接，而不是一个套接字。
　套接字和链接差异：比如一个server可以和ｎ个client链接，一个server与一个client之间是建立一个链接，但是一个server用一个套接字
　
* __传输可靠性:__　
 传输可靠性性就是通过确认号实现的，发送端发送一个分段之后，接下来接收端就要发送一个确认，发送端收到确认后才发送下一个分段
 这就是所谓的“停止－等待”协议。不过TCP采用了滑窗机制使得每一次发送的数据量大小不确定。这种场景就存在一个可能确认报文没有
 收到的情况，有可能时确认报文丢失导致一直等待下去，有可能是报文还在链路上未到达导致数据多发。因此要解决确认号等待时间

 * 疑难４：超时时间计算：
  
  >
  除了考虑每两次测量值的偏差之外，其变化率也应该考虑在内，如果变化率过大，则通过以变化率为自变量的函数为主计算RTT(如果陡然
  增大，则取值为比较大的正数，如果陡然减小，则取值为比较小的负数，然后和平均值加权求和)，反之如果变化率很小，则取测量平均值

 * 疑难５：超时计时器管理--每个链接一个超时计时器:
  
  >
  采用每一个TCP分段一个计时器的，管理方便，但是对内存和调度开销太大，因此默认都采用一个链接一个计时器。    
  a.发送TCP分段时，如果还没有重传定时器开启，那么开启它。   
  b.发送TCP分段时，如果已经有重传定时器开启，不再开启它。   

 * 疑难６：如何测量RTT:

  >
  目前很多TCP实现了时间戳，这样就方便多了，发送端再也不需要保存发送分段的时间了，只需要将其放入协议头的时间戳字段，然后接收
  端将其回显在ACK即可，然后发送端收到ACK后，取出时间戳，和当前时间做算术差，即可完成一次RTT的测量。
  
