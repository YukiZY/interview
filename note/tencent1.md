14.信号：
  软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。进程之间可以互相通过系统调用kill发送软中断信号。
  内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。注意，信号只是用来通知某进程发生了什么事件，
  并不给该进程传递任何数据。大部分的信号的缺省操作是使得进程终止
  
15.用户态与内核态：
  Intel x86架构的CPU来说一共有0~3四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查
  对于Unix/Linux来说，只使用了0级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在0级特权级的指令具有了CPU能提供的最高权力，
  而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力，当程序运行在3级特权级上时，就可以称之为运行在用户态，
  因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在0级特权级上时，就可以称之为运行在内核态用户态切换到  
  内核态的3中方式：系统函数调用(主动)，异常（被动），外围设备中断(被动)触发方式上看，可以认为存在前述3种不同的类型，
  但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，
  没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的
  
16.TCP三次握手状态：
  第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 
  第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
  第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 
  完成三次握手，客户端与服务器开始传送数据.
  
17.死锁、检测、解除：
  死锁4条件：
  a.互斥条件：进程对所分配资源有排他性，即在一定的时间段内某资源只能被一个进程独享，其他进程申请占有该资源，只能等待
  b.不可剥夺条件：即一个进程获取某资源之后，在没有主动释放之前，其他进程不能强制剥夺该资源，只能有当前占有该资源的进程主动释放才可以
  c.请求与保持条件：即一个进程已经获得了某个资源，此时又去申请另外一个资源，待申请资源又被其他进程所占有且没有释放，此时请求进程被阻塞但是又没有释放自身占有的资源
  d.循环等待条件：存在一个进程资源的循环等待链，链中每一个进程已经获得的资源又被链中下一个进程请求
  死锁预防：
  a.破坏互斥条件：允许资源都可以共享使用，但是有些资源根本不能同时访问，比如打印机等临界资源只能互斥访问，因此不太行
  b.破换不可剥夺条件：当一个已经保持了某些不可剥夺资源的进程，在请求新的资源而不可满足时，就必须释放已经占有的资源，待以后需要时重新申请，
   但是实现比较复杂，且会导致前一阶段的工作的失效，反复申请和释放也会增加系统调度开销
  c.破坏请求与保持条件：预先分配资源，进程执行之前先预先申请所有资源，只有所以资源都申请ok之后才开始执行，执行过程中不再申请资源，
   实现简单，但是会造系统资源的浪费，因为某些资源可能只有在进程开始或者结束时才使用，一直占有就会导致浪费
  d.破坏循环等待条件：给系统资源编号，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源，但是增加编程麻烦
  死锁避免：不是破坏死锁的4条件，而是在资源分配的过程中动态检测
  系统安全状态：
    是指系统能按某种进程推进顺序( P1, P2, ...,Pn)，
    为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序地完成。此时称 P1, P2, ..., Pn 
    为安全序列。如果系统无法找到一个安全序列，则称系统处于不安全状态。
  银行家算法：
    银行家算法是最著名的死锁避免算法。它提出的思想是：把操作系统看做是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。
  死锁解除：
   a.资源剥夺法：挂起某些死锁进程并剥夺他的资源给其他等待资源的进程
   b.撤销进程法：强制撤销部分或者全部死锁进程，并剥夺这些进程资源
   c.进程回退法：让多个进程回退到足以回避死锁的地步，进程回退时资源释放占有的资源
  
18.  linux系统的同步机制和互斥机制：
  
19：linux的exit()和_exit():
  linux中退出一个进程的方式分为正常退出和异常退出，但不管哪种退出，都会调用内核中同一段代码关闭进程所有已打开的文件描述符fd、释放内存和资源
  正常退出：在main中调用return或者调用exit()/_exit()；
  异常退出：调用abort函数或者收到某个信号，该信号导致程序终止；
  调用exit()或者_exit(),系统都会无条件的停止所有操作，清除包括PCB在内的各种数据结构、资源、内存，并终止本进程的运行。
  区别：
  a.两个函数所在的头文件不一样，exit是stdlib.h、_exit()是unistd.h
  b._exit()会终止进程，但不关闭文件，不清除输出缓存，也不调用出口函数；exit函数将终止调用进程。在退出程序之前，所有文件关闭，
  缓冲输出内容将刷新定义，并调用所有已刷新的“出口函数”
  c.exit()是系统调用_exit()的封装，exit()在调用exit系统会检查文件的打开情况，将文件缓冲区的内容全部写入文件在关闭，而_exit()会直接关闭进程，导致文件缓冲区中的数据丢失，一次要保证数据的完整性就一定要调用exit()
  
20.linux文件读写的“缓冲I/O”：
  Linux的标准函数库中，有一种被称作“缓冲I/O”的操作，其特征就是对应每一个打开的文件，在内存中都有一片缓冲区。
  每次读文件时，会连续的读出若干条记录，这样在下次读文件时就可以直接从内存的缓冲区读取；
  同样，每次写文件的时候也仅仅是写入内存的缓冲区，等满足了一定的条件（如达到了一定数量或遇到特定字符等），
  再将缓冲区中的内容一次性写入文件。这种技术大大增加了文件读写的速度，但也给编程代来了一点儿麻烦
  
#####21.linux内存管理机制：
  [内存管理机制详解](http://blog.csdn.net/yusiguyuan/article/details/23554927)
