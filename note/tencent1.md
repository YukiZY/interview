####14.信号：
* __软中断信号__（signal，又简称为信号）用来通知进程发生了异步事件。进程之间可以互相通过系统调用kill发送软中断信号。

> 内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。
  注意，信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据。大部分的信号的缺省操作是使得进程终止
  
####15.用户态与内核态：
  * Intel x86架构的CPU来说一共有0~3四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查
    对于Unix/Linux来说，只使用了0级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在0级特权级的指令具有了CPU能提供的最高权力，
    而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力，当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特
    级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在0级特权级上时，就可以称之为运行在内
    态用户态切换

  * 内核态调用的3中方式：系统函数调用(主动)，异常（被动），外围设备中断(被动)触发方式上看，可以认为存在前述3种不同的类型，
    但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，
    因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的
  
####16.TCP三次握手状态：
  * __第一次握手__：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 
  * __第二次握手__：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），
    即SYN+ACK包，此时服务器进入SYN_RECV状态；
  * __第三次握手__：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，
    完成三次握手。 
  * 完成三次握手，客户端与服务器开始传送数据.
  
####17.死锁、检测、解除：
  * __死锁4条件__：
   * a.__互斥条件__：进程对所分配资源有排他性，即在一定的时间段内某资源只能被一个进程独享，其他进程申请占有该资源，只能等待
   * b.__不可剥夺条件__：即一个进程获取某资源之后，在没有主动释放之前，其他进程不能强制剥夺该资源，
       只能有当前占有该资源的进程主动释放才可以
   * c.__请求与保持条件__：即一个进程已经获得了某个资源，此时又去申请另外一个资源，待申请资源又被其他进程所占有且没有释放，
       此时请求进程被阻塞但是又没有释放自身占有的资源
   * d.__循环等待条件__：存在一个进程资源的循环等待链，链中每一个进程已经获得的资源又被链中下一个进程请求
   
  * __死锁预防__：
   * a.__破坏互斥条件__：允许资源都可以共享使用，但是有些资源根本不能同时访问，比如打印机等临界资源只能互斥访问，因此不太行
   * b.__破换不可剥夺条件__：当一个已经保持了某些不可剥夺资源的进程，在请求新的资源而不可满足时，就必须释放已经占有的资源，
       待以后需要时重新申请，但是实现比较复杂，且会导致前一阶段的工作的失效，反复申请和释放也会增加系统调度开销
   * c.__破坏请求与保持条件__：预先分配资源，进程执行之前先预先申请所有资源，只有所以资源都申请ok之后才开始执行，
       执行过程中不再申请资源，实现简单，但是会造系统资源的浪费，因为某些资源可能只有在进程开始或者结束时才使用，一直占有就会导致浪费
   * d.__破坏循环等待条件__：给系统资源编号，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源，
       但是增加编程麻烦
       
  * __死锁避免__：不是破坏死锁的4条件，而是在资源分配的过程中动态检测
   * __系统安全状态__：
    *  是指系统能按某种进程推进顺序( P1, P2, ...,Pn)，为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，
       使每个进程都可顺序地完成。此时称 P1, P2, ..., Pn 为安全序列。如果系统无法找到一个安全序列，则称系统处于不安全状态。
   * __银行家算法__：
    *  银行家算法是最著名的死锁避免算法。它提出的思想是：把操作系统看做是银行家，操作系统管理的资源相当于银行家管理的资金，
       进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，
       要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。
       当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。
       若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，
       否则也要推迟分配。
       
  * __死锁解除__：
   *  __资源剥夺法__：挂起某些死锁进程并剥夺他的资源给其他等待资源的进程
   *  __撤销进程法__：强制撤销部分或者全部死锁进程，并剥夺这些进程资源
   *  __进程回退法__：让多个进程回退到足以回避死锁的地步，进程回退时资源释放占有的资源
  
####18.  linux系统的同步机制和互斥机制：
 
####19：linux的exit()和_exit():
  * linux中退出一个进程的方式分为__正常退出__和__异常退出__，但不管哪种退出，都会调用内核中同一段代码关闭进程所有已打开的
    文件描述符fd、释放内存和资源
  * __正常退出__：在main中调用return或者调用exit()/_exit()；
  * __异常退出__：调用abort函数或者收到某个信号，该信号导致程序终止；
  * 调用exit()或者_exit(),系统都会无条件的停止所有操作，清除包括PCB在内的各种数据结构、资源、内存，并终止本进程的运行。
  
  * __区别__：
   * a.两个函数所在的头文件不一样，exit是stdlib.h、_exit()是unistd.h
   * b._exit()会终止进程，但不关闭文件，不清除输出缓存，也不调用出口函数；exit函数将终止调用进程。在退出程序之前，所有文件关闭，
      缓冲输出内容将刷新定义，并调用所有已刷新的“出口函数”
   * c.exit()是系统调用_exit()的封装，exit()在调用exit系统会检查文件的打开情况，将文件缓冲区的内容全部写入文件在关闭，
      而_exit()会直接关闭进程，导致文件缓冲区中的数据丢失，一次要保证数据的完整性就一定要调用exit()
  
####20.linux文件读写的“缓冲I/O”：
  * Linux的标准函数库中，有一种被称作“缓冲I/O”的操作，其特征就是对应每一个打开的文件，在内存中都有一片缓冲区。
    每次读文件时，会连续的读出若干条记录，这样在下次读文件时就可以直接从内存的缓冲区读取；
    同样，每次写文件的时候也仅仅是写入内存的缓冲区，等满足了一定的条件（如达到了一定数量或遇到特定字符等），
    再将缓冲区中的内容一次性写入文件。这种技术大大增加了文件读写的速度，但也给编程代来了一点儿麻烦
  
####21.linux内存管理机制：
  [内存管理机制详解](http://blog.csdn.net/yusiguyuan/article/details/23554927)
  * linux虚拟内存实现需要6种机制的支持：__地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机制、内存共享机制__
  * __物理内存和虚拟内存__：
   * __物理内存__：硬件提供的真实的内存
   * __虚拟内存__：linux为了满足物理内存不够的场景，利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间就称之为
       交换空间(swap space),当物理内存不够用时，内核就会将内存暂时不使用的内存块信息交换到交换空间，这样一来，物理内存就得到了释放，
       就可以用于其他目的，当需要使用原始数据时，这些数据就会从交换空间读入到物理内存中，内核会在不需要内存的时候也会不时的进行
       内存交换，以避免需要内存时的等待交换时间，采用“最近经常使用”算法进行页面交换。
       
  * __地址__：
   * __逻辑地址__：指由程序产生的与段相关的偏移地址部分。在C语言指针中，读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，
       它是相对于你当前进程数据段的地址
   * __线性地址__：段中的偏移地址（逻辑地址），加上相应段的基地址就生成了一个线性地址
   * __物理地址__：放在寻址总线上的地址
   * __虚拟地址__：保护模式下段和段内偏移量组成的地址，而逻辑地址就是代码段内偏移量，或称进程的逻辑地址
   
  * __地址转换__：Linux采用段页式管理机制，有两个部件用于地址转换：分段部件和分页部件。
   * __分段部件__：将逻辑地址转换为线性地址。分段提供了隔绝各个代码、数据和堆栈区域的机制，因此多个程序（任务）可以运行在
      同一个处理器上而不会互相干扰
   * __分页部件__：将线性地址转换为物理地址（页表和页目录），若没有启用分页机制，那么线性地址直接就是物理地址
   
  * __6种机制的应用__：

 > 内存管理通过地址映射机制将逻辑地址映射到物理地址上（在地址映射中要通过TLB(翻译后援存储器)来寻找物理页），当用户程序运行时，
   发现程序中需要使用的虚拟内存没有对应的物理内存，就会用请求页机制发出请求页要求，如果有空闲的内存可供分配，就会采用
   内存分配回收机制请求分配内存，并采用缓存和刷新机制将把正在使用的物理页记录在缓存中，如果没有足够的内存可供分配，
   在采用交换机制将部分暂时不使用的内存交换到swap空间，腾出部分内存
