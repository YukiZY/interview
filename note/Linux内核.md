## linux内存分配机制：

* Linux应用程序在内存中的布局，由高地址到低地址依次为：栈、Memory mapping、堆、BSS段、数据段、代码段。
  代码段的起始地址固定为0x8048000，无论哪一个应用程序它的代码段起始地址一定是0x8048000，这里的地址虚拟地址，映射到不同的物理地址中去。

####1. 地址
* 逻辑地址：是指由程序产生的与段相关的偏移地址部分，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。
* 虚拟地址：在保护模式下，段和段内偏移量组成的地址，其实就是线性地址
* 线性地址：段中的偏移地址（逻辑地址），加上相应段的基地址就生成了一个线性地址
  
  >
    线性地址的本质就是“CPU所看到的地址”,而线性地址就是用于描述CPU可见的这4GB空间,我们知道在多进程操作系统中，每个进程拥有独立的地址空间，
    拥有独立的资源。但对于某一个特定的时刻，只有一个进程运行于CPU之上。此时，CPU看到的就是这个进程所占用的4GB空间，就是这个线性地址。
    而CPU所做的操作，也是针对这个线性空间而言的。之所以叫线性空间，大概是因为人们觉得这样一个连续的空间排列成一线更加容易理解吧。
    其实就是CPU的可寻址范围
* 物理地址：是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。

  >
    如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。
    如果没有启用分页机制，那么线性地址就直接成为物理地址了
####2.内存:
* 虚拟内存：是指计算机呈现出要比实际拥有的内存大得多的内存量。因此它允许程序员编制并运行比实际系统拥有的内存大得多的程序。
  这使得许多大型项目也能够在具有有限内存资源的系统上实现

  >
  计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率
* 物理内存：实际的内存。物理地址被分成离散的单元，成为页（page）。目前大多数系统的页面大小都为4k。CPU外部地址总线上的寻址信号，
  是地址变换的最终结果，一个物理地址始终对应实际内存中的一个存储单元
####3.地址转换:
* linux将逻辑地址转换为物理地址需要两步：
  
  逻辑地址 -----[分段管理机制]-----> 线性地址 -------[分页管理机制]------> 物理地址

 * 分段机制：
  * 首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，
  * 看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。
  * 拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。
  * 把Base + offset，就是要转换的线性地址了。

  >
    一个逻辑地址由两部份组成，段标识符: 段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。
    其中前13位是一个索引号。后面3位包含一些硬件细节
    索引号：就是“段描述符”，具体的描述了一个段，然后很多的段描述符就组成一个“段描述符表”，这样，可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符，这样就可以找到一个具体的段.   
    GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中

 __不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段__
 __在Linux下，逻辑地址与线性地址总是一致（是一致，不是有些人说的相同）的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。！！！__
 
 * 分页机制：
  
  
[linux内存布局](http://www.cnblogs.com/51qianrushi/p/4294264.html)
