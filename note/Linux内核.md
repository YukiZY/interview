## [linux内存分配机制](http://blog.csdn.net/wxzking/article/details/5905214)：

* [Linux应用程序在内存中的布局，由高地址到低地址依次为：栈、Memory       mapping、堆、BSS段、数据段、代码段](http://www.cnblogs.com/51qianrushi/p/4294264.html)
  代码段的起始地址固定为0x8048000，无论哪一个应用程序它的代码段起始地址一定是0x8048000，这里的地址虚拟地址，映射到不同的物理地址中去。。

####1. 地址
* 逻辑地址：是指由程序产生的与段相关的偏移地址部分，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。
* 虚拟地址：在保护模式下，段和段内偏移量组成的地址，其实就是线性地址
* 线性地址：段中的偏移地址（逻辑地址），加上相应段的基地址就生成了一个线性地址
  
  >
    线性地址的本质就是“CPU所看到的地址”,而线性地址就是用于描述CPU可见的这4GB空间,我们知道在多进程操作系统中，每个进程拥有独立的地址空间，
    拥有独立的资源。但对于某一个特定的时刻，只有一个进程运行于CPU之上。此时，CPU看到的就是这个进程所占用的4GB空间，就是这个线性地址。
    而CPU所做的操作，也是针对这个线性空间而言的。之所以叫线性空间，大概是因为人们觉得这样一个连续的空间排列成一线更加容易理解吧。
    其实就是CPU的可寻址范围
* 物理地址：是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。

  >
    如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。
    如果没有启用分页机制，那么线性地址就直接成为物理地址了

####2.内存:
* 虚拟内存：是指计算机呈现出要比实际拥有的内存大得多的内存量。因此它允许程序员编制并运行比实际系统拥有的内存大得多的程序。
  这使得许多大型项目也能够在具有有限内存资源的系统上实现

  >
  计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率
* 物理内存：实际的内存。物理地址被分成离散的单元，成为页（page）。目前大多数系统的页面大小都为4k。CPU外部地址总线上的寻址信号，
  是地址变换的最终结果，一个物理地址始终对应实际内存中的一个存储单元

####3.地址转换:
* linux将逻辑地址转换为物理地址需要两步：
  
  逻辑地址 -----[分段管理机制]-----> 线性地址 -------[分页管理机制]------> 物理地址

* 分段机制：
  * 在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值(index)。
  
 __转换过程__:
  * 首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]；段选择符分为：[13位Index 1位Ti 2位RPL]
  * 看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。
  * 拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，得到了Base，即基地址就知道了。
  * 把Base + offset，就是要转换的线性地址了。

  >
    例：假如一个完整的逻辑地址：[000000000001111 0 11:0xB0495B0],首先根据逻辑地址中的段选择符的第14位Ti标志获取时GDT还是LDT
    (linux不论是内核任务还是用户任务，都只用GDT，不用LDT，GDT的第12和13项段描述符是 __KERNEL_CS 和__KERNEL_DS，第14和15项段描述符是 __USER_CS 和__USER_DS),然后根据逻辑地址中的段选择符的前13位index找到对应段，然后就可以获取对应的段的基地址，再加上逻辑地址就获取到了线性地址。

 __不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段__
 __在Linux下，逻辑地址与线性地址总是一致（是一致，不是有些人说的相同）的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。！！！__
 因为因为Linux所有的段（用户代码段、用户数据段、内核代码段、内核数据段）的线性地址都是从 0x00000000 开始，长度4G。
 
* 分页机制（二级页内存管理模式）：
  * CPU的页式内存管理单元，负责把一个线性地址，最终翻译为一个物理地址.从管理和效率的角度出发，线性地址被分为以固定长度为单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20次方个页.   
  * __这个大数组我们称之为页目录。目录中的每一个目录项，就是一个地址——对应的页的地址__    
  * 另一类“页”，我们称之为物理页，或者是页框、页桢的。是分页单元把所有的物理内存也划分为固定长度的管理单位，它的长度一般与内存页是一一对应的。
  
  >
    1、分页单元中，页目录是唯一的，它的地址放在CPU的cr3寄存器中，是进行地址转换的开始点。万里长征就从此长始了。  
    2、每一个活动的进程，因为都有其独立的对应的虚似内存（页目录也是唯一的），那么它也对应了一个独立的页目录地址。——运行一个进程，需要将它的页目录地址放到cr3寄存器中，将别个的保存下来。   
    3、每一个32位的线性地址被划分为三部份：页目录索引(10位)：页表索引(10位)：偏移(12位)  
  
  __转换过程__:
  * 每一个进程里面，分页单元中的页目录是唯一的，它的地址由OS负责在进程调度的时候放入到对应的cr3寄存器中，转换开始时取出页目录地址
  * 根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。
  （又引入了一个数组），页的地址被放到页表中去了。
  * 根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址
  * 将页的起始地址与线性地址中最后12位相加，得到最终我们想要的地址
  
  >
    例：假如一个转换后的线性地址为：0x80495b0（0000100000 0001001001 010110110000），转换开始时，
    首先从cr3寄存器中取出页目录表，然后根据前面线性地址的前10位DIRECTORY（二进制）转换为页目录表中的索引32，然后从页目录表中的32位置处
    取出页表地址，然后在取线性地址中间10位TABLE转换为73，去页中的73位置处取出页地址，然后这时候就索引到了某一个具体的物理页，然后
    再加上线性地的最后12位1456就获取到了具体的物理地址索引。

[linux内存布局](http://www.cnblogs.com/51qianrushi/p/4294264.html)
