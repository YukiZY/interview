一般而言，关系数据库设计的目标是生成一组关系模式，使我们存储信息时避免不必要的冗余，并且可以让我们方便地获取信息。这是通过设计满足适当范式（normal form）的模式来实现的。

##[1、主键、外键](https://github.com/zhangxiaoyuan/interview/blob/master/note/database/database%E5%9F%BA%E7%A1%80.md#8键定义):

关系型数据库中的一条记录中有若干个属性，若其中某一个`属性组`(注意是组)能唯一标识一条记录，该`属性组`就可以成为一个主键。比如下面的三个表中（主键用下划线标注）。

* 学生表( _学号_ ，姓名，性别，班级) 
* 课程表( _课程编号_ ，课程名，学分) 
* 成绩表( _学号，课程号_ ，成绩)

其中每个学生的学号是唯一的，学号就是一个主键。其中课程编号是唯一的，课程编号就是一个主键。成绩表中单一一个属性无法唯一标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以学号和课程号的属性组是一个主键。

成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的`外键`。同理成绩表中的课程号是课程表的外键。外键用于与另一张表的关联，是能确定另一张表记录的字段，用于保持数据的一致性。

主键主要有两个用途：

1. 惟一地标识一行。
2. 作为一个可以被外键有效引用的对象。

［[候选关键字](http://www.nowcoder.com/questionTerminal/088587c25467478884128c0cb31eeeb8)］  
［[主键、外键](http://www.nowcoder.com/questionTerminal/70100692594e4130a6b3efe344ef3874)］  

##2、[三大范式](https://www.zhihu.com/question/24696366)：
###三范式简单理解：
 * 1.数据原子性：每一列属性都不可再分割
 * 2.非主属性完全依赖于主键[消除部分子函数依赖]
 * 3.非主属性不依赖于其它非主属性[消除传递依赖]
 
###第一范式：
一个域是原子的，如果该域的元素被认为是不可分的单元。如果 R 的所有属性的域都是原子的，则称关系模式 R 属于第一范式。   
仅仅符合1NF的设计，会存在数据冗余过大，插入异常，删除异常，修改异常的问题：    
[[例子](https://github.com/zhangxiaoyuan/CS_Offer/blob/master/DataBase/Design.md#原子域和第一范式)]

###第二范式：
第二范式在第一范式的基础上，**消除了非主属性对于候选码的部分函数依赖。实际就是使非主属性不再依赖候选码中部分主属性。**

若在一张表中，**在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说 Y 函数依赖于 X，写作 X➞Y**。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确.

从“函数依赖”这个概念展开，还会有三个概念：

* `完全函数依赖`：在一张表中，若 X➞Y，且对于X的任何一个真子集（假如属性组X包含超过一个属性的话）X'➞Y 不成立，那么我们称Y对于X完全函数依赖。
* `部分函数依赖`：假如Y函数依赖于X，但同时Y并不完全函数依赖于X，那么我们就称Y部分函数依赖于X。
* `传递函数依赖`：假如Z函数依赖于Y，且Y函数依赖于X （严格来说还有一个X不包含于Y，且Y不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于X。

**包含在任何一个候选码中的属性称为主属性**。如果数据表中存在非主属性对于候选码的部分函数依赖，则数据表不符合 2NF 的要求，否则，符合2NF。    
[[例子](https://github.com/zhangxiaoyuan/CS_Offer/blob/master/DataBase/Design.md#第二范式)]

###第三范式：
3NF 在 2NF 的基础上，**消除了非主属性对于候选码的传递函数依赖**。也就是说如果存在非主属性对于候选码的传递函数依赖，则不符合3NF的要求。**实际上就是使非主属性不再传递函数依赖候选码中的部分主属性。**     
[[例子](https://github.com/zhangxiaoyuan/CS_Offer/blob/master/DataBase/Design.md#第三范式)]     
满足3NF后情况有了很大的改观，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。

##3、BCNF范式：
在 3NF 的基础上，消除了非主属性对于候选码的部分函数依赖与传递函数依赖。

存在着主属性对于候选码的部分函数依赖与传递函数依赖。在此例中就是存在主属性【仓库名】对于候选码（管理员，物品名）的部分函数依赖。

解决办法就是要在 3NF 的基础上消除主属性对于候选码的部分函数依赖与传递函数依赖。

##4、范式还是反范式：
范式化的数据库中，每个事实数据出现并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。

范式化设计的好处：

范式化的更新操作通常比反范式化要快；
当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要更改更少的数据；
范式化的表通常更小，可以更好地放在内存中，所以执行操作会快；
范式化设计的一个缺点是通常需要关联，稍微复杂一些的查询语句在符合范式的 schema 上都可能需要至少一次关联。不但代价昂贵，也可能使一些索引策略无效。

反范式化的 schema 因为所有数据都放在一张表中，可以很好地避免关联。单独的表也能使用更有效的索引策略。

实际应用中，可以使用部分 schema、缓存表等技巧。最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。在新版本的Mysql中，可以使用触发器更新缓存值。


 
