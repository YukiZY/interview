##1.视图：
让所有用户都看到整个逻辑模型是不合适的，此外有时候希望创建一个比逻辑模型更符合特定用户直觉的个人化的关系集合。因此，SQL 允许通过查询来定义虚关系，它在概念上包含查询的结果。**虚关系并不预先计算并存储，而是在使用虚关系的时候才通过执行查询进行计算**。任何像这种不是逻辑模型的一部分，但作为虚关系对用户可见的关系称为视图（View）。   

SQL 中用 create view 命令来定义视图，为了定义视图，必须给它一个名称，并提供计算视图的查询，如下格式：   

create view v as <query expression>;    

一旦定义了一个视图之后，可以用视图名指代视图生成的虚关系。在查询中，视图名可以出现在关系名可以出现的任何地方。视图关系出现在查询中时，实际上已经被存储的查询表达式代替，**因此，无论何时执行这个查询，视图关系都会被重新计算**。此外，一个视图可以被用到定义另一个视图的表达式中。

###视图更新
对查询来说，视图时一个有用的工具，但是如果用它们来表达更新、插入或者删除，可能会带来严重的问题。困难在于，用视图表达的数据库修改必须被翻译为对数据库逻辑模型中实际关系的修改。因此，除了一些有限的情况外，一般不允许对视图关系进行更新。   

不同的数据库系统指定了不同的条件以允许更新视图关系。一般来说，如果定义的视图查询对下列条件都满足，则称 SQL 视图是可更新的（即视图上可以执行插入、更新或删除）：   
 * from 子句中只有一个数据库关系  
 * select 子句中只包含关系的属性名，不包含任何表达式、聚集或 distinct 声明
 * 任何没有出现在 select 子句中的属性可以取空值，即这些属性没有 not null 约束，也不构成主码的一部分
 * 查询中不含有 group by 或 having 子句。

##2.完整性约束：
完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性，防止对数据的意外破坏。完整性约束通常被看作是数据库模式设计过程的一部分，作为用于创建关系的一部分被声明。比如下面的例子：
 * 教师名不能为 null
 * 任意两位教师不能有相同的教师标识
 * 一个系的预算必须大于 0.00 美元
 
允许的完整性约束有 ：

 * __not null 约束(外键约束)__：声明在属性上禁止插入空值；
 * __unique 约束(唯一性约束)__：unique(A1, A2,..., An) 声明指出属性 A1, A2,..., An 形成了一个候选码。注意候选码属性可以为 null（除非显式地声明为 not null）。
 * __check 约束(检查约束)__：check(p) 字句指定谓词 p，关系中的每个元组必须满足谓词p，这里 p 可以是包含子查询在内的任意谓词。
 * __参照完整性约束__：保证一个关系中给定属性集上的取值也在另一关系的特定属性集的取值中出现。（外码约束）

##3.触发器：
触发器是一种特殊的存储过程，它在插入，删除或修改特定表中的数据时触发执行，它比数据库本身标准的功能有更精细和更复杂的数据控制能力。注意事项：

 * 只有表才可以支持触发器，视图和临时表都不支持触发器
 * 每个表的每个事件只支持一个触发器，因此每个表最多支持6个触发器
 * 单一触发器不能与多个操作相关
 * 触发器不能更新和覆盖，如果想更新一个触发器必须先删除，再创建
 
###触发器怎么工作的?
答：触发器主要是通过事件进行触发而被执行的，当对某一表进行诸如UPDATE、 INSERT、 DELETE 这些操作时，数据库就会自动执行触发器所定义的SQL 语句，从而确保对数据的处理必须符合由这些SQL 语句所定义的规则

##4.[MySql常用命令](http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html)

##5.储存过程：
存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库。中用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程用于实现频繁使用的查询、业务规则、被其他过程使用的公共例行程序。存储过程在创建时即在服务器上进行编译，所以执行起来比单个 SQL 语句快

##6.基础概念：
表：关系relation  
行：元组tuple   
列：属性attribute    
关系实例(relation instance)：关系的特性实例，也就是一组特定的行   
属性域(domain):关系的每个属性的取值范围
数据库模式(db schema):数据库的逻辑设计
数据库实例(db instance)：给定时刻数据库中数据的一个快照

##7.[SQL中不同连接方式](http://blog.jobbole.com/40443/)：    
* EQIU JOIN：       
 + Inner Join(普通连接):JOIN    
 + Outer Join(外连接): LFET JOIN、RIGTH JOIN、FULL OUTER JOIN         
* SEMI JOIN：       
 + 这种连接关系在 SQL 中有两种表现方式：使用 IN，或者使用 EXISTS。        
  ```sql
   -- Using IN
   FROM author
   WHERE author.id IN (SELECT book.author_id FROM book)

   -- Using EXISTS
   FROM author
   WHERE EXISTS (SELECT 1 FROM book WHERE book.author_id = author.id)
  ```
  
* ANTI JOIN:       
 + 这种连接的关系跟 SEMI JOIN 刚好相反。在 IN 或者 EXISTS 前加一个 NOT 关键字就能使用这种连接  
   
* CROSS JOIN：      
 + 这个连接过程就是两个连接的表的乘积：即将第一张表的每一条数据分别对应第二张表的每条数据。我们之前见过，这就是逗号在 FROM 语句中的用法      
   
* DIVISION：        
 + DIVISION 的确是一个怪胎。简而言之，如果 JOIN 是一个乘法运算，那么 DIVISION 就是 JOIN 的逆过程。DIVISION 的关系很难用 SQL 表达出来     
  
##8.键定义：
* 定义：
 + 主键 -- 唯一标识一条记录，不能有重复的，不允许为空
 + 外键 -- 表的外键是另一表的主键 ,  外键可以有重复的 ,  可以是空值
 + 索引 -- 该字段没有重复值，但可以有一个空值
* 作用：
 + 主键 -- 用来保证数据完整性
 + 外键 -- 用来和其他表建立联系用的
 + 索引 -- 是提高查询排序的速度  
* 个数：
 + 主键 -- 主键只能有一个
 + 外键 -- 一个表可以有多个外键
 + 索引 -- 一个表可以有多个唯一索

##9.码：

一个关系中没有两个元组在所有属性上的值相同，因此一个元组的属性值必须要能够唯一区分元组。

`超码`（super key）是一个或者多个属性的集合，这些属性的集合能够唯一地标识一个关系中的一个元组。超码中可以包含无关紧要的属性，如果 k 是一个超码，那么 k 的任意超集也是超码。

`候选码`（candidate key）：任意真子集都不能成为超码的超码，也即最小超码。有可能有多个不同的属性集都可以做候选码。

`主码`（primary key）：被数据库设计者选中的，主要用来在一个关系中区分不同元组的候选码。主码的选择必须慎重，应该选择那些值从来不变或者极少变化的属性。

码是整个关系的一种性质，而不是单个元组的性质。码的指定代表了被建模的事物在现实世界中的约束。

此外，一个关系模式（如r1）可能在它的属性中包括另一个关系模式（如r2）的主码，这个属性在r1上称作参照r2的`外码`（foreign key）。

##10.关系代数：
关系代数是一种过程化查询语言，包括一个运算的集合。这些运算以一个或者两个关系作为输入，产生一个新的关系作为结果。关系代数的基本运算有：选择、投影、并、集合差、笛卡尔积和更名。在基本运算外，还有一些其它运算，即集合交、自然连接和赋值。

### 基本关系代数运算

| 基本关系运算 |          解释       |
|------------|--------------------|
|  选择 σ   | 从关系的水平方向进行运算，选择满足给定条件的元组组成新的关系  | 
|  投影 π   | 从关系的垂直方向开始运算，选择关系中的若干列组成新的列          |
|    并    | R,S 具有相同的关系模式，RUS 为属于R或者S的元组|
|  集合差  | R,S 具有相同的关系模式，R-S为属于R但不属于S的元组 |
|  笛卡儿积 | 从两个输入关系中输出所有的元组对（无论它们在共同属性上的取值是否相同）  |
| 更名 ρ  | 将更名运算运用于关系 r，得到一个具有新名字的相同关系 |

### 附加关系代数运算

通过定义一些附加的运算，虽然不能增强关系代数的表达能力，却可以简化一些常用的查询。

|附加关系运算 |          解释       |
|------------|--------------------|
|集合交运算   | R,S具有相同的关系模式，R∩S=R-(R-S) |
|自然连接 ⋈  |  R⋈S 的结果是在R和S中的在它们的公共属性名字上相等的所有元组的组合。 |
| 赋值运算 ←| 类似程序语言中的赋值，将 ← 右侧的表达式的结果赋给左侧的关系变量，该关系变量可以在后续的表达式中使用  |
| 左外链接 ⟕ | R ⟕ S，包含R中所有元组，对每个元组，若在S中有在公共属性名字上相等的元组，则正常连接，若在S中没有在公共属性名字上相等的元组，则依旧保留此元组，并将对应其他列设为NULL |
| 右外链接 ⟖ | R ⟖ S，外连接的结果包含S中所有元组，对每个元组，若在R中有在公共属性名字上相等的元组，则正常连接，若在R中没有在公共属性名字上相等的元组，则依旧保留此元组，并将对应其他列设为NULL。 |
| 全外链接 ⟗ | R ⟗ S，全外连接的结果包含R与S中所有元组，对每个元组，若在另一关系上中有在公共属性名字上相等的元组，则正常连接，若在另一关系上中没有在公共属性名字上相等的元组，则依旧保留此元组，并将对应其他列设为NULL。|
