##1.视图：
让所有用户都看到整个逻辑模型是不合适的，此外有时候希望创建一个比逻辑模型更符合特定用户直觉的个人化的关系集合。因此，SQL 允许通过查询来定义虚关系，它在概念上包含查询的结果。**虚关系并不预先计算并存储，而是在使用虚关系的时候才通过执行查询进行计算**。任何像这种不是逻辑模型的一部分，但作为虚关系对用户可见的关系称为视图（View）。   

SQL 中用 create view 命令来定义视图，为了定义视图，必须给它一个名称，并提供计算视图的查询，如下格式：   

create view v as <query expression>;    

一旦定义了一个视图之后，可以用视图名指代视图生成的虚关系。在查询中，视图名可以出现在关系名可以出现的任何地方。视图关系出现在查询中时，实际上已经被存储的查询表达式代替，**因此，无论何时执行这个查询，视图关系都会被重新计算**。此外，一个视图可以被用到定义另一个视图的表达式中。

###视图更新
对查询来说，视图时一个有用的工具，但是如果用它们来表达更新、插入或者删除，可能会带来严重的问题。困难在于，用视图表达的数据库修改必须被翻译为对数据库逻辑模型中实际关系的修改。因此，除了一些有限的情况外，一般不允许对视图关系进行更新。   

不同的数据库系统指定了不同的条件以允许更新视图关系。一般来说，如果定义的视图查询对下列条件都满足，则称 SQL 视图是可更新的（即视图上可以执行插入、更新或删除）：   
 * from 子句中只有一个数据库关系  
 * select 子句中只包含关系的属性名，不包含任何表达式、聚集或 distinct 声明
 * 任何没有出现在 select 子句中的属性可以取空值，即这些属性没有 not null 约束，也不构成主码的一部分
 * 查询中不含有 group by 或 having 子句。

##2.完整性约束：
完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性，防止对数据的意外破坏。完整性约束通常被看作是数据库模式设计过程的一部分，作为用于创建关系的一部分被声明。比如下面的例子：
 * 教师名不能为 null
 * 任意两位教师不能有相同的教师标识
 * 一个系的预算必须大于 0.00 美元
 
允许的完整性约束有 ：

 * __not null 约束(外键约束)__：声明在属性上禁止插入空值；
 * __unique 约束(唯一性约束)__：unique(A1, A2,..., An) 声明指出属性 A1, A2,..., An 形成了一个候选码。注意候选码属性可以为 null（除非显式地声明为 not null）。
 * __check 约束(检查约束)__：check(p) 字句指定谓词 p，关系中的每个元组必须满足谓词p，这里 p 可以是包含子查询在内的任意谓词。
 * __参照完整性约束__：保证一个关系中给定属性集上的取值也在另一关系的特定属性集的取值中出现。（外码约束）

##3.触发器：
触发器是一种特殊的存储过程，它在插入，删除或修改特定表中的数据时触发执行，它比数据库本身标准的功能有更精细和更复杂的数据控制能力。注意事项：

 * 只有表才可以支持触发器，视图和临时表都不支持触发器
 * 每个表的每个事件只支持一个触发器，因此每个表最多支持6个触发器
 * 单一触发器不能与多个操作相关
 * 触发器不能更新和覆盖，如果想更新一个触发器必须先删除，再创建
 
###触发器怎么工作的?
答：触发器主要是通过事件进行触发而被执行的，当对某一表进行诸如UPDATE、 INSERT、 DELETE 这些操作时，数据库就会自动执行触发器所定义的SQL 语句，从而确保对数据的处理必须符合由这些SQL 语句所定义的规则

##4.[MySql常用命令](http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html)

##5.储存过程：
存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库。中用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程用于实现频繁使用的查询、业务规则、被其他过程使用的公共例行程序。存储过程在创建时即在服务器上进行编译，所以执行起来比单个 SQL 语句快

##6.基础概念：
表：关系relation  
行：元组tuple   
列：属性attribute    
关系实例(relation instance)：关系的特性实例，也就是一组特定的行   
属性域(domain):关系的每个属性的取值范围
数据库模式(db schema):数据库的逻辑设计
数据库实例(db instance)：给定时刻数据库中数据的一个快照

##7.SQL中不同连接方式：    
* EQIU JOIN：       
 + Inner Join(普通连接):JOIN    
 + Outer Join(外连接): LFET JOIN、RIGTH JOIN、FULL OUTER JOIN         
* SEMI JOIN：       
   - 这种连接关系在 SQL 中有两种表现方式：使用 IN，或者使用 EXISTS。       
    ```sql
     -- Using IN
     FROM author
     WHERE author.id IN (SELECT book.author_id FROM book)

     -- Using EXISTS
     FROM author
     WHERE EXISTS (SELECT 1 FROM book WHERE book.author_id = author.id)
    ```
  
* ANTI JOIN:       
   这种连接的关系跟 SEMI JOIN 刚好相反。在 IN 或者 EXISTS 前加一个 NOT 关键字就能使用这种连接  
   
* CROSS JOIN：      
   这个连接过程就是两个连接的表的乘积：即将第一张表的每一条数据分别对应第二张表的每条数据。我们之前见过，这就是逗号在 FROM 语句中的用法     
   
* DIVISION：        
   DIVISION 的确是一个怪胎。简而言之，如果 JOIN 是一个乘法运算，那么 DIVISION 就是 JOIN 的逆过程。DIVISION 的关系很难用 SQL 表达出来    
  


