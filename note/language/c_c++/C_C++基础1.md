####1.基本数据类型：
 整形(signed/unsigned char/short/int/long/bool)、浮点(float/double)、void
 
####2.常量类型：
 整形常量、浮点型常量、字符常量、字符串常量、转义字符常量、地址常量
 
####3.操作符分类：
* 操作数分类：一元操作符，二元操作符，三元操作符
* 功能分类：算数操作符、关系操作符、逻辑操作符、位操作符、赋值操作符、自增自减操作符、箭头操作符、条件操作符、sizeof操作符、逗号操作符

####4.变量初始化：
* 直接初始化（利用构造函数初始化）: int a(100);
* 赋值初始化：int a = 100;
 
####5.变量作用域：
 全局作用域、局部作用域、语句作用域
 
####6.switch语句中定义变量
 只能在最后一个case标号（没有default分支的情况下）或者default标号后面定义变量，或者引入块语句来定义变量
 
####7.流输入输出：

* * * 
                    ios
    istream  fstreambase  strstreambase  ostream

    ifstream::istream fstreambase
    ofstream::ostream fstreambase
    istrstream::istream strstreambase
    ostrstream::ostream strstreambase

    iostream::istream ostream
    fstream::iostream fstreambase
    strstream::iostream strstreambase

####8.动态内存分配：
 * int* p = new int;  delete p;
 * int* q = new int[100];  delete[] q;
 
####9.虚函数和纯虚函数：
 * __虚函数__：虚函数在基类中定义且必须是非静态函数，然后在基类中实现，也可在子类中重载(虚函数要必须在非抽象类中实现，一般就直接带个｛｝表示实现，不具体实现)
 * __[纯虚函数](http://www.cnblogs.com/xudong-bupt/p/3570304.html)__:必须在抽象类中定义，定义了纯虚函数的类就是抽象类，抽象类中可以定义非纯虚函数，这些函数通过多态形式被调用，在抽象类中定义的非纯虚函数必须要实现，抽象类中定义的虚函数和纯虚函数是在运行时动态加载的（多态的原理），但是抽象类中的定义的非虚函数（普通函数），则是在编译的时候已经绑定，因此不能实现多态（多态的原理）
 * __多态实现__：父类的引用指向子类的实例
 
####10.构造函数和析构函数：
* 有继承类时(Class Son : Class Father)，有三种情况，不同情况构造函数和析构函数使用不同：
  * a.Father* father = new Father();  delete father;  
   单独构造基类实例时，只调用基类的构造函数和析构函数处理
  * b.Son* son = new Son();  delete son;   单独构造子类实例时，先调用父类构造函数，在调用子类构造函数，析构时先调用子类析构函数，在调用父类析构函数(不论父类的析构函数是否为虚函数)
  * c.Father* fatherRef = new Son(); delete fatherRef;  
   使用多态实现基类引用指向子类实例时，先调用父类构造函数，再调用子类构造函数，析构时先调用子类析构函数，再调用父类析构函数  
   （父类的析构函数必须定义为虚函数，如果父类析构函数不是虚函数，则析构时不会调用子类的析构函数进行析构，导致只析构父类，不析构子类，内存泄漏

####11.虚析构函数：
* 构造函数为什么不能定义为虚函数？
  虚函数的执行依赖于虚函数表，而虚函数表在构造函数中进行初始化工作，即初始化vptr,让他指向正确的虚函数表，而在构造对象期间，虚函数表还没有初始化，因此  无法进行。

* 析构函数定义为虚函数的原理(在存在继承并且子类有资源需要释放时，父类的析构函数需要定义为虚函数，否则会导致子类的资源不能释放，内存泄漏):  
 + 对于基类，如果有虚函数，那么闲存放虚函数表指针vptr，然后存放自己的数据成员，如果没有虚函数，那么直接存放数据成员  
 + 对于单一继承的类对象，先存放父类的数据拷贝(父类的虚函数指针vptr和数据成员)，然后子类自己的数据成员    
 + 在子类的虚函数表中，如果子类未重载父类的虚函数，那么先存放父类的虚函数，再存放子类的虚函数  
 + 在子类的虚函数表中，如果子类重载了付乐的某些虚函数，那么子类新的虚函数将覆盖自己虚函数表中的父类虚函数(父类的虚函数表不变化)  
 + 对于多重继承，在子类虚函数表中，先存放第一个父类的数据拷贝(包括vprt和数据成员)，然后是第二个父类的数据拷贝，以此类推，如果子类覆盖了某个父类的       虚函数，那么就将相应的父类的vptr指向的虚函数表中的父类的虚函数覆盖，如果子类有自己的虚函数，那么存放在第一个父类的虚函数之后    
   
**如果将基类的析构函数声明为虚函数时，由该基类所派生的所有派生类的析构函数也都自动成为虚函数，即使派生类的析构函数与基类的析构函数名字不相同** 

**如果基类没有定义虚析构函数，派生类的析构函数不能调用到的原因是：因为指针虽然指向的内存是派生类的，但是指针本身是基类，所以用delete时实际析构的是基类，所以调用了基类的析构函数而没有调用派生类的析构函数**   

**如果基类定义了析构函数，派生类的析构函数能调用到的原因是：当基类定义了虚析构函数，那么基类就会生成一个虚函数表指向基类的虚析构函数，当派生类继承了基类的时候，根据上面的定论，派生类的析构函数也会自动变成虚函数，所以派生类也会生成vptr和虚函数表，但是这里非常重要的点《派生类的虚析构函数会重载基类的虚析构函数，所以在派生类的虚函数表中派生类的虚函数会覆盖基类的虚函数》，因此在通过基类指针delete时，因为基类的析构函数已经被派生类的析构函数动态覆盖了，所以就调用到了派生类的析构函数，又因为编译器在构造类的时候，会将基类的析构函数添加在派生类的析构函数之后，所以通过调用派生类的析构函数就可以调用到基类的析构函数。--实际上跟普通的虚函数是一样的，不过有一点差异：《虽然基类和派生类的虚析构函数名字不一样，但是派生类的虚析构函数会覆盖基类的虚析构函数，就像普通虚函数一样，派生类的同名虚函数会覆盖基类的虚函数》**

####12. 结构体与类:
 * c语言只有结构体的概念，在C++中可以在结构体中声明函数，但是在C语言中是不允许的
 * 实例化的类对象存储中堆内存中，而结构存储在栈内存中，结构的执行效率比较高，结构没有析构函数
 
####13.静态成员： 
 * 类的静态成员变量可以作为成员函数的可选参数，但是普通成员变量不可以 
 * 类的静态成员变量的类型可以是所属类的类型，但是普通成员变量类型就只能是所属类类型的指针或引用
 * 类的静态方法只能访问类的静态成员变量
 
####14.const修饰函数： 
 * const int* func();   表示返回值的内容不能被修改，这个函数表示返回值只能赋值给const修饰的同类型指针，这种个表示”按地址传递方式”
 * const int fun();     这种用法无意义，因为函数返回值会复制一份给外面调用函数的变量，因此加const无意义，这种表示“按值传递方式”
 * int* const fun();    作用同上
 * int const fun();     作用同上
 * int* fun() const;    表示类的成员函数进行修饰，修饰之后表示这个函数不可以对这个类的非静态成员变量进行修改（静态成员变量可以修改）
 * int func() const;    作用同上
 
####15.C++多态：
 * __动态多态__：采用面向对象的继承和父类引用指向子类实例特性
 * __静态多态__：采用C++泛型模板特性
 * __函数多态__：采用重载实现，相同的函数名称和返回值，不同的函数列表
 * __宏多态__：采用宏定义实现初级形式的静态多态
 
####16.深拷贝和浅拷贝： 
  * 如果一个类中拥有资源，那么在复制的过程中如果发生资源重新分配，这就是深拷贝，反之就是浅拷贝
  * 比如，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这
  增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误
   
####17.复制构造函数和类型转化构造函数：
  * __复制构造函数__:又称为拷贝构造函数，是一种特殊的构造函数，它由编译器调用来完成一些基于同一类的其他对象的构建及初始化，有3中使用场景
   * 一个对象以值传递的方式传入函数体
   * 一个对象已值传递的方式从函数返回
   * 一个对象需要通过另外一个对象进行初始化
  * __类型转化构造函数__:一个类的构造函数只有一个参数，并且这个参数不是该类的类型而是其他类型，这个构造函数就称为类型转换构造函数
  
####18.静态函数访问非静态成员变量:
  * a.将非静态成员变量修改为成员变量
  * b.在静态函数的形参中加上实例对象
  * c.定义类的全局变量
  * d.如果类时单例，将this指针赋值给静态类类型的成员变量
  * e.在静态函数的形参上添加void*指针
  
####19.模板：
 * __函数模板__：使用了模板技术定义了参数化类型的非成员函数，这使得程序能够使用不同的参数类型调用相同的函数
 * __类模板__：描述了能够管理其他数据类型的通用数据类型，类模板技术通常用于建立包含其他类型的容器类

####20.表结构
 * 线性表-物理内存上连续
 * 链表-单链表，双向链表，循环链表
 * 队列-队列的顺序实现和链表实现
 * 栈-栈的顺序实现和链表实现
 
####21.树的三种遍历:
* __前序遍历__：根-左-右  下示例：abdefgc
* __中序遍历__：左-根-右  下示例：debgfac
* __后序遍历__：左-右-根  下示例：edgfbca  

* * *
         a
        / \
       b   c
     /  \
    d    f
    \   / 
     e g
     
    前序遍历：abdefgc
    中序遍历：debgfac
    后序遍历：edgfbca

####21.设计模式：
 * __创建型模__式：抽象了类的实例化过程，帮助系统如何创建、组合、表示那些对象
   * 工厂模式(FACTORY)、生成器模式(BUILDER)、工厂方法模式(FACTORY METHOD)、原型模式(PROTOTYPE)、单例模式(SINGLETON)
 * __行为型模式__：解决类实体之间的通讯关系，描述一个控制流程
   * 职责链模式(CHAIN OF RESPONSIBLEITY)、命令模式(COMMAND)、解释器模式(INTERPRETER)、迭代器模式(ITERATOR)、中介者模式(MEDIATOR)、备忘录模式(MEMENTO)、观察者模式(OBSERVER)、状态模式(STATE)、策略模式(STRATEGY)、模板方法模式(TEMPLATE METHOD)、访问者模式(VISITOR)
 * __结构型模式__：如何组合类与对象以获得更大的结构，采用继承机制组合接口与实现
   * 适配器模式(ADAPTER)、桥接模式(BRIDGE)、合成模式(COMPOSITE)、装饰者模式(DECORATOR)、外观模式(FACADOR)、享元模式(FLYWEIGHT)、代理模式(PROXY)
   
####22.关系数据库设计范式：
 * 第一范式(1NF):确保数据库列中的值不重复（实体中的某个属性不能有重复值或者不能有重复的属性）
 * 第二范式(2NF):要求数据库表中的每个行必须可以被唯一的区分，为实现区分通常将表的一个或者多个属性作为行的唯一标识，该标识称之为主键
 * 第三范式(3NF):要求数据库中的表的非主键列之间不能有依赖
 
####23.数据库事务4个特性：
 * __原子性__：事务是一个逻辑工作单位，要么全部执行，要么全部不执行
 * __一致性__：指事务执行的结果从一个一致性状态到另一个一致性状态，
 * __隔离性__：事务之间不能互相干扰
 * __持续性__：事务一旦提交，对数据库中的数据修改是永久性的
 
####24.进程与线程：
 * 资源分配的最小单位是进程，应用程序的运行实例，运营程序的一个动态实例，由进程控制块、程序段、数据段3部分组成，
 * 系统调度的基本单位是线程，是进程的一个实体，不拥有系统资源，与其他线程共享同一个进程的资源，多线程之间并发执行
 
####25.操作系统调度算法：
 * __先来先服务算法(FCFS)__：按作业到达先后顺序
 * __最短作业优先算法(SJF)__：减少平均周转时间，对预计执行时间短的作业先调度，后来的短作业不抢先正在执行的作业
 * __最高响应比优先算法(HRN)__：同时综合FCFS和SJF算法，同时考虑每个作业等待时间和执行时间的长短，从中选出响应比高的作业
 * __基于优先数调度算法(HPF)__：按照优先级高低调度

###26.makefile编写：
```makefile
     makedir mf
     cd mf
     vim makefile.mk
     hello.o:hello.c hello.h
       gcc -c hello.o -Lm
     make  
     ./hello     
     
     预处理-----> 编译 ----> 汇编 ----> 链接 
     #gcc -E hello.c -o hello.i
     #gcc –S hello.i –o hello.s 
     #gcc –c hello.s –o hello.o 
     #gcc hello.o –o hello.exe 
     #./hello.exe
```
