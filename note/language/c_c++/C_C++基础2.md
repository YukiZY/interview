####1.实时操作系统的特征：
> 特定时间内完成特定的任务，实时性和可靠性

####2.变量在内存中的分配：
 > 
 * 栈－由编译器分配释放，主要存放函数入参，局部变量等
 * 堆－由程序员分配释放，主要存放malloc/calloc/new的内存，如不手动释放，程序结束由OS回收
 * 静态区(全局区)-主要存放全局变量(普通和静态变量)和静态局部变量，，有区分初始化区和未初始化区，程序结束由OS释放
 * 文字常量区-主要存放常量值，程序结束有OS释放
 * 程序代码去-主要存放函数体的二进制代码

####3.二叉树、平衡二叉树、完全二叉树、满二叉树
 > 
 * 二叉树：每个结点最多有两个子树的有序树
 * 平衡二叉树：当且仅当两个子树的高度差不超过1时的二叉树，左右子树都是平衡二叉树
 * 完全二叉树：若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层从右向左连续缺若干结点，这就是完全二叉树。
 * 满二叉树：每一层上的结点数都是最大结点数
 * 二叉堆：父节点总是大于或者小于左右子节点，大顶堆或者小顶堆
 * 二叉查找树：中序遍历呈递增
 * AVL树：二叉平衡查找树，特殊的二叉查找树
 * 红黑树：查找树，特殊的AVL树
 
####4.switch()的参数只能实型：
 > 只能是byte、char、short、int、long，不能是float、double、string等，因为他们不能用==比较

####5.局部变量和全局变量可以重名:
> 在局部变量作用域中局部变量会屏蔽全局变量，直接使用变量名就是局部变量，但是使用“::”就是全局变量

####6.普通全局变量和静态全局变量:
 > 存储方式和位置都一样，都是在静态数据区，但是作用域范围不一样，普通全局变量是整个源程序，多个文件都可以访问，但是静态全局变量只能是在定义的文件中使用

####7.普通函数和静态static函数：
> static函数在内存中只有一份拷贝，而普通函数在每次调用时都有一份拷贝，static函数只能在当前定义文件中使用，而普通函数可以被外部函数调用

####8.const用法：
 > 
 * const int a;     //常整形数
 * int const a;     //常整形数
 * const int* a;    //指向常整形数的指针(指针是可以改变的，但是指针指向的整形数是常整形数，不能修改)
 * int* const ａ;   //指向整形数的常指针(指针是常量类型指针，指针的值不能修改，但是指针指向的整形数可以修改的)
 * const int* const a; //指向常整形数的常指针(指针是常量类型指针，指针的值不能修改，指针指向的整形也是常量，也不能修改).
 
####9. 函数指针和指针函数：
 > 最简单的辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数
 * 指针函数：首先他是一个函数，只不过函数的返回值是一个指针：类型说明符 * 函数名(参数)
 * 函数指针：指向函数的指针变量，本身是一个指针变量，指向函数的指针包含了函数的地址，通过指针可以调用函数：类型说明符 (*函数名)(参数)
 * int *a[10] : 一个有10个整形数指针的数组
 * int (*a)[10]:  一个指向有10个整形数数组的指针
 * int *func(int a): 指针函数，返回值是指针
 * int (*func)(int a): 函数指针，一个指向函数的指针
 * int func(double a)   int(*pfunc)(double para)   pfunc = func： 函数指针，一个指向函数的指针p,函数指针的类型与函数返回值类型一致
 
####10.结构与联合：
 > 结构和联合都是由不同的数据类型成员组成，但在任何一个时刻，联合中只存储一个选中的数据类型的值，
 > 而结构是全部数据的集合堆结构内的数据赋值，互相之间不影响，但是对联合赋值，将会对其他成员重写，导致原来的成员值就不存在

####11.位操作：

    #define BIT(n) (1UL << (n))
    #define BIT_SET(a,n) ((a) |= BIT(n))
    #define BIT_CLR(a,n) ((a) &= ~BIT(n))
 
####12.单向链表中，不知道头结点，一个指针指向一个节点，如何删除这个节点
 > 将当前节点的下一个节点的数据复制给当前节点，然后删除当前节点的下一个节点，就相当于删除了当前节点

    Node nextNode = curNode->next;
    if (nextNode)
    {
        curNode->data = nextNode-data;
        curNode->next = nextNode->next;
        delete nextNode;
    }

####13.C语言整数转换原则：
 > 表达式中有符号数和无符号数操作时总会转换成无符号数进行操作

####14.OSI七层网络模型
#####OSI中的层 功能 TCP/IP协议族
> 
* 应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet
* 表示层 数据格式化，代码转换，数据加密 没有协议
* 会话层 解除或建立与别的接点的联系 没有协议
* 传输层 提供端对端的接口 TCP，UDP
* 网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP
* 数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU
* 物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2

####15.MVC模式
 > Model/view/controller,实现数据与视图的隔离，通过将系统分层和接口，实现各层之间的解耦
 
####16.进程同步机制
 > 
 * 信号量的P&V操作：管理临界资源，操作简单，信号量只能赋一次初值，之后只能进行P&V操作，因此必须有公共内存，不能用于分布式系统
 * 自旋锁：
 * 管程：
 * 会合：
 * 分布式系统：
 
####17.进程通信机制：
 > 
 * 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
 * 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
 * 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
 * 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
 * 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
 * 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
 * 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
