####1.位操作：
[位操作主要用于操作寄存器之类的硬件强相关的或者数据变化使用](http://blog.csdn.net/morewindows/article/details/7354571)
* __& 按位与__: 两个位都为1时，结果才为1
* __| 按位或__: 两个位都为0时，结果才为0
* __^ 按位异或:__: 两个位相同为0，相异为1
* __~ 按位取反__: 0变1，1变0
* __<< 左移__: 各二进位全部左移若干位，高位丢弃，低位补0
* __>> 右移__:各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）

###2.STL容器：
* __顺序容器__：
 * __vector__:
  连续存储元素，底层采用数组方式实现，连续内存保存，在尾部插入和随机查找或存取高效，随机插入和删除就耗时，可以插入相同元素，可以使用算法中的sort函数   按照自定义的顺序对vector中的元素排序,元素不够时再重新分配内存，拷贝原来数组的元素到新分配的数组中。
 * __list__:
  连续存储元素，底层采用__环状双向链表方__式实现，随机插入和删除高效，但是随机查找和存取耗时，可以插入相同元素，使用list自身的sort函数对list中元素按照自定义顺序排序，list不能使用std::sort排序，是因为std::sort的容器必须支持随机访问，所以使用自带list::sort。
 * __deque__:
  分配中央控制器map(并非map容器)，map记录着一系列的固定长度的数组的地址.记住这个map仅仅保存的是数组的地址,真正的数据在数组中存放着.deque先从map中央的位置(因为双向队列，前后都可以插入元素)找到一个数组地址，向该数组中放入数据，数组不够时继续在map中找空闲(向后添加就找后一个位置的数组，向前添加就找前一个位置的数组)的数组来存数据。当map也不够时重新分配内存当作新的map,把原来map中的内容copy的新map中，然后销毁之前的map,所以使用deque的复杂度要大于vector,所以尽量使用vector。
 * __stack__:基于deque。
 * __queue__:基于deque。
 * __heap__:完全二叉树，以vector的形式存放，使用大顶堆排序。
 * __priority_queue__:基于heap堆。
 * __slist__:
* __关联容器__：　　
　* __set__*：
 　包括一个键值，set容器中的数据都是顺序排列，set中数据如果是自定义数据，则必须要传入比较函数，集合中数据不重复，底层采用RB树实现，在随机插入和删除高效，但是查找或添加末尾元素耗时，因为是已经排序的序列，所以查找采用二分查找，效率O(logn)
  * __map__*：
  键值关联容器，内存中采用红黑树实现，且key值唯一，集合中key值不重复，key采用红黑树(特殊的平衡二叉查找数)存储，因此查找效率是O(logn)。
  * __hash_map__:
  键值关联容器，内存中ｋｅｙ值采用hashtable实现，key值不一定唯一，使用hash函数将key值映射到数组中，然后用list存储value值，使用开链法解决冲突，查找效率O(１),hash_map的查找效率高，key值也不能重复，重复的时通过hash()函数计算之后的hash值有可能重复。
  * __hash_table__:
  散列表。将待存数据的key经过映射函数变成一个数组(一般是vector)的索引，例如：数据的key%数组的大小＝数组的索引(一般文本通过算法也可以转换为数字)，然后将数据当作此索引的数组元素。有些数据的key经过算法的转换可能是同一个数组的索引值(碰撞问题，可以用线性探测，二次探测来解决)，STL是用开链的方法来解决的，每一个数组的元素维护一个list，他把相同索引值的数据存入一个list，这样当list比较短时执行删除，插入，搜索等算法比较快。
  * __set,map,multiset,multimap__:基于红黑树(RB-tree)，一种加上了额外平衡条件的二叉搜索树。
  * __hash_map,hash_set,hash_multiset,hash_multimap__:基于hashtable
  * __红黑树特征__：特殊的AVL树，根节点必须是黑色；每个叶节点是黑色；每个红色节点的两个子节点都是黑色；从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
  * __AVL树__:特殊的二叉查找树，在二叉查找树的基础上增加左右子树高度差小于1的特征
 
####2.GCC编译四个过程：ESC选项分别生成iso文件
* 1）预处理(Pre-processing)
  在该阶段，编译器将C源代码中的包含的头文件如stdio.h编译进来，用户可以使用gcc的选项”-E”进行查看。
  选项 -E
  用法:#gcc -E hello.c -o hello.i
  作用：将hello.c预处理输出hello.i文件。

* 2)编译阶段(Compiling)
  第二步进行的是编译阶段，在这个阶段中，Gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，
  Gcc把代码翻译成汇编语言。用户可以使用”-S”选项来进行查看，该选项只进行编译而不进行汇编，生成汇编代码。
  选项 -S
  用法：[root]# gcc –S hello.i –o hello.s
  作用：将预处理输出文件hello.i汇编成hello.s文件。

* 3)汇编阶段(Assembling)
  汇编阶段是把编译阶段生成的”.s”文件转成二进制目标代码. 
  选项 -c
  用法：[root]# gcc –c hello.s –o hello.o
  作用：将汇编输出文件test.s编译输出test.o文件。 

* 4）链接阶段(Link)
  在成功编译之后，就进入了链接阶段。
  无选项链接  
  用法：[root]# gcc hello.o –o hello.exe
  作用：将编译输出文件hello.o链接成最终可执行文件hello.exe。

####3.String类的实现：

```c++
 class String
 {
 public:
      String(const char *str = NULL);// 普通构造函数
      String(const String &other);    // 拷贝构造函数
      ~ String(void);    // 析构函数
      String & operate =(const String &other);// 赋值函数
 private:
      char *m_data;// 用于保存字符串
 }; 
 请编写String的上述4个函数。
 
 //普通构造函数
 String::String(const char *str)
 {
         if(str==NULL)
         {
                 m_data = new char[1]; // 得分点：对空字符串自动申请存放结束标志'\0'的//加分点：对m_data加NULL 判断
                 *m_data = '\0';
         }    
         else
         {
          int length = strlen(str);
          m_data = new char[length+1]; // 若能加 NULL 判断则更好
          strcpy(m_data, str);
         }
 } 
 
 // String的析构函数
 String::~String(void)
 {
         delete [] m_data; // 或delete m_data;
 }
 
 //拷贝构造函数
 String::String(const String &other) 　　　// 得分点：输入参数为const型
 {     
         int length = strlen(other.m_data);
         m_data = new char[length+1]; 　　　　//加分点：对m_data加NULL 判断
         strcpy(m_data, other.m_data);    
 } 
 
 //赋值函数
 String & String::operate =(const String &other) // 得分点：输入参数为const型
 {     
         if(this == &other)                  　　//得分点：检查自赋值
                 return *this; delete [] m_data; 　　　　//得分点：释放原有的内存资源
         int length = strlen( other.m_data );      
         m_data = new char[length+1]; 　//加分点：对m_data加NULL 判断
         strcpy( m_data, other.m_data );   
         return *this;     　　　　　　　　//得分点：返回本对象的引用  
 
 }
 ```
 >当类中包括指针类成员变量时，一定要重载其拷贝构造函数、赋值函数和析构函数
 
####4.虚函数的实现和作用：
 在有虚函数的类中，每一个虚函数都有一个虚函数指针，这些指针组成一个虚函数表VTbl，在编译的阶段，编译器会自动加入虚表，虚表的使用方法如
 下：__如果派生类在自己的定义中没有修改父类的虚函数，那么虚函数指针就指向父类的虚函数，如果派生类重写了基类的虚函数，此时虚表Vtbl中的
 指针就指向派生类重载的虚函数__。   
 C++中虚函数使用__虚函数表Vtbl__和__虚函数表指针Vptr__实现，__虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地址__，
 假如子类的虚函数重写了父类的虚函数，__则对应在虚函数表中会把对应的虚函数替换为子类的虚函数的地址__；虚函数表指针存在于每个对象中
 （通常出于效率考虑，会放在对象的开始地址处)，它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向
 对应不同基类的虚函数表
 
>
 __一个对象访问普通成员函数和虚函数哪个更快？__
 访问普通成员函数更快，因为普通成员函数的地址在编译阶段就已确定，因此在访问时直接调  用对应地址的函数，而虚函数在调用时，需要首先在虚函数表中寻找虚函数所在地址，因此相比普 通成员函数速度要慢一些。  

>
 __[在什么情况下，析构函数需要是虚函数？](http://blog.csdn.net/pathuang68/article/details/4156308)__
 在存在类继承并且析构函数中需要析构某些资源是析构函数需要是虚函数，否则若使用父类指 针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，造成内存泄露。  
 
>
 __内联函数、构造函数、静态成员函数可以是虚函数吗？__
 都不可以。内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开；
 构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类
 的，因此不存在动态绑定的概念；静态成员函数是以类为单位的函数，与具体对象无关，虚函数是 与对象动态绑定的，因此是两个不冲突的概念；
 虚函数对应一个vtable，这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数

####5.指针和引用
 * 相同点：都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。
 * 区别：
  * 1. 指针是一个实体，而引用仅是个别名；
  * 2. 引用使用时无需解引用(*)，指针需要解引用；
  * 3. 引用只能在定义时被初始化一次，之后不可变；指针可变；
  * 4. 引用没有 const，指针有 const；
  * 5. 引用不能为空，指针可以为空；
  * 6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；
  * 7. 指针和引用的自增(++)运算意义不一样；
  * 8.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。

####6.构造和析构顺序：
 先调用基类的构造函数，在调用派生类的构造函数
 先构造的后析构，后构造的先析构

####7.杂:
* extern "C" : c++编译的时候，对函数名进行修饰，用于实现函数充载，而c里面没有这个， 所以需要用extern “C” 在对头文件进行声明的时候加以区分。告知编译器采用不同的编译和连接方式
* volatile：CPU内存数据缓存寄存器机制，编译器会在编译时将代码优化，导致可能读取“脏数据”，因此告知编译器不优化代码，每次都从内存读取数据
* hash: 取其他合数时，都会不同程度的导致c的某些位”失效”，从而在一些常见应用中导致冲突．但是取质数，基本可以保证c的每一位都参与H( c )的运算，从而在常见应用中减小冲突几率.
* const的含义及实现机制，比如：const int i,是怎么做到i只可读的?  --编译器相关,优化可能让其直接转为一常量代入.
 
####8.查看系统是32位还是64位：

```c++
 int k= -1;  //int k = ~0;
 if ((unsigned int)k > 0xFFFFFFFF)
 {
     cout << k << " " <<(unsigned int)k <<" at least 32bits" << endl;
 }
 else
 {
     cout << k << " " <<(unsigned int)k <<" at least 64bits" << endl;
 }
```
####9.查看当前系统是大端序还是小端序：
* __大端序__：高位字节排放在内存低地址，低位字节排放再内存高地址
* __小端序__：低位字节排放在内存低地址，高位字节排放在内存高地址
* __网络序是按照大端序__

```c++
 typedef union
 {
     unsigned int a;
     unsigned char b[4];
 }Test;
 
 int main(int argc, const char * argv[])
 {
    
     Test test;
     test.a = 0x12345678;
     cout << test.b[0] << " "<< test.b[1] << " "<< test.b[2] << " "<< test.b[3] << " " <<endl;
     if (test.b[0] == 0x12 && test.b[1] == 0x34 && test.b[2] == 0x56 && test.b[3] == 0x78)
     {
         cout << "big ending" << endl;
     }
     else
     {
         cout << "little ending" << endl;
     }
  }
 ```
