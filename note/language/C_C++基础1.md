####1.基本数据类型：
> 整形(signed/unsigned char/short/int/long/bool)、浮点(float/double)、void
 
####2.常量类型：
> 整形常量、浮点型常量、字符常量、字符串常量、转义字符常量、地址常量
 
####3.操作符分类：
>
* 操作数分类：一元操作符，二元操作符，三元操作符
* 功能分类：算数操作符、关系操作符、逻辑操作符、位操作符、赋值操作符、自增自减操作符、箭头操作符、条件操作符、sizeof操作符、逗号操作符

####4.变量初始化：
> 
* 直接初始化（利用构造函数初始化）: int a(100);
* 赋值初始化：int a = 100;
 
####5.变量作用域：
 > 全局作用域、局部作用域、语句作用域
 
####6.switch语句中定义变量
 > 只能在最后一个case标号（没有default分支的情况下）或者default标号后面定义变量，或者引入块语句来定义变量
 
####7.流输入输出：

* * * 
                    ios
    istream  fstreambase  strstreambase  ostream

    ifstream::istream fstreambase
    ofstream::ostream fstreambase
    istrstream::istream strstreambase
    ostrstream::ostream strstreambase

    iostream::istream ostream
    fstream::iostream fstreambase
    strstream::iostream strstreambase

####8.动态内存分配：
 >
 * int* p = new int;  delete p;
 * int* q = new int[100];  delete[] q;
 
####9.虚函数和纯虚函数：
 >
 * __虚函数__：虚函数在基类中定义且必须是非静态函数，然后在基类中实现，也可在子类中重载
 * __纯虚函数__:必须在抽象类中定义，定义了纯虚函数的类就是抽象类，抽象类中可以定义非纯虚函数，这些函数通过多态形式被调用，在抽象类中定义的非纯虚函数必须要实现，抽象类中定义的虚函数和纯虚函数是在运行时动态加载的（多态的原理），但是抽象类中的定义的非虚函数（普通函数），则是在编译的时候已经绑定，因此不能实现多态（多态的原理）
 * __多态实现__：父类的引用指向子类的实例
 
####10.构造函数和析构函数：
  > 
* 有继承类时(Class Son : Class Father)，有三种情况，不同情况构造函数和析构函数使用不同：
  * a.Father* father = new Father();  delete father;  
   单独构造基类实例时，只调用基类的构造函数和析构函数处理
  * b.Son* son = new Son();  delete son;   单独构造子类实例时，先调用父类构造函数，在调用子类构造函数，析构时先调用子类析构函数，在调用父类析构函数(不论父类的析构函数是否为虚函数)
  * c.Father* fatherRef = new Son(); delete fatherRef;  
   使用多态实现基类引用指向子类实例时，先调用父类构造函数，再调用子类构造函数，析构时先调用子类析构函数，再调用父类析构函数  
   （父类的析构函数必须定义为虚函数，如果父类析构函数不是虚函数，则析构时不会调用子类的析构函数进行析构，导致只析构父类，不析构子类，内存泄漏,因为基类的析构函数定义为虚函数时，这个类就有一个虚函数指针指向子类的虚函数表，然后再delete基类指针时，就可以同过虚函数指针将子类也删除，避免内存泄漏）

####11. 结构体与类:
 > 
 * c语言只有结构体的概念，在C++中可以在结构体中声明函数，但是在C语言中是不允许的
 * 实例化的类对象存储中堆内存中，而结构存储在栈内存中，结构的执行效率比较高，结构没有析构函数
 
####12.静态成员：
 > 
 * 类的静态成员变量可以作为成员函数的可选参数，但是普通成员变量不可以 
 * 类的静态成员变量的类型可以是所属类的类型，但是普通成员变量类型就只能是所属类类型的指针或引用
 * 类的静态方法只能访问类的静态成员变量
 
####13.const修饰函数：
 > 
 * const int* func();   表示返回值的内容不能被修改，这个函数表示返回值只能赋值给const修饰的同类型指针，这种个表示”按地址传递方式”
 * const int fun();     这种用法无意义，因为函数返回值会复制一份给外面调用函数的变量，因此加const无意义，这种表示“按值传递方式”
 * int* const fun();    作用同上
 * int const fun();     作用同上
 * int* fun() const;    表示类的成员函数进行修饰，修饰之后表示这个函数不可以对这个类的非静态成员变量进行修改（静态成员变量可以修改）
 * int func() const;    作用同上
 
####14.C++多态：
 > 
 * __动态多态__：采用面向对象的继承和父类引用指向子类实例特性
 * __静态多态__：采用C++泛型模板特性
 * __函数多态__：采用重载实现，相同的函数名称和返回值，不同的函数列表
 * __宏多态__：采用宏定义实现初级形式的静态多态
 
####15.深拷贝和浅拷贝：
  > 
  * 如果一个类中拥有资源，那么在复制的过程中如果发生资源重新分配，这就是深拷贝，反之就是浅拷贝
  * 比如，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这
  增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误
   
####16.复制构造函数和类型转化构造函数：
  > 
  * __复制构造函数__:又称为拷贝构造函数，是一种特殊的构造函数，它由编译器调用来完成一些基于同一类的其他对象的构建及初始化，有3中使用场景
   * 一个对象以值传递的方式传入函数体
   * 一个对象已值传递的方式从函数返回
   * 一个对象需要通过另外一个对象进行初始化
  * __类型转化构造函数__:一个类的构造函数只有一个参数，并且这个参数不是该类的类型而是其他类型，这个构造函数就称为类型转换构造函数
  
####17.静态函数访问非静态成员变量:
  > 
  * a.将非静态成员变量修改为成员变量
  * b.在静态函数的形参中加上实例对象
  * c.定义类的全局变量
  * d.如果类时单例，将this指针赋值给静态类类型的成员变量
  * e.在静态函数的形参上添加void*指针
  
####18.模板：
 >
 * __函数模板__：使用了模板技术定义了参数化类型的非成员函数，这使得程序能够使用不同的参数类型调用相同的函数
 * __类模板__：描述了能够管理其他数据类型的通用数据类型，类模板技术通常用于建立包含其他类型的容器类

####19.容器：
>* __顺序容器__： 
  * __vector__：  
   连续存储元素，底层采用数组方式实现，连续内存保存，在尾部插入和随机查找或存取高效，随机插入和删除就耗时，
   可以插入相同元素，可以使用算法中的sort函数按照自定义的顺序对vector中的元素排序
  * __deque__:  
  是一种优化了的、对序列两端元素进行添加和删除操作的基本序列容器。它允许较为快速地随机访问，但它不像vector把所有
  的对象保存在一块连续的内存块，而是采用多个连续的存储块，并且在一个映射结构中保存对这些块及其顺序的跟踪。向deque两端添加或删
  除元素的开销很小。它不需要重新分配空间  ，所以向末端增加元素比vector 更有效
  * __list__：  
  连续存储元素，底层采用双向链表方式实现，随机插入和删除高效，但是随机查找和存取耗时，可以插入相同元素，使用list自身的sort函数对list中元素按照自定义顺序排序，list不能使用std::sort排序，是因为std::sort的容器必须支持随机访问，所以使用自带list::sort
  
* * * 
>* __关联容器__：
 * __set__:  
  包括一个键值，set容器中的数据都是顺序排列，set中数据如果是自定义数据，则必须要传入比较函数，集合中数据不重复，底层采用RB树实现，在随机插入和删除高效，但是查找或添加末尾元素耗时，因为是已经排序的序列，所以查找采用二分查找，效率O(logn)
  * __map__:  
  键值关联容器，内存中采用红黑树实现，且key值唯一，集合中key值不重复，key值采用hashtable实现,所以直接对索引查找是O(1)
 
####20.表结构
 > 
 * 线性表-物理没存上连续
 * 链表-单链表，双向链表，循环链表
 * 队列-队列的顺序实现和链表实现
 * 栈-栈的顺序实现和链表实现
 
####21.树的三种遍历:
>
* __前序遍历__：根-左-右  下示例：abdefgc
* __中序遍历__：左-根-右  下示例：debgfac
* __后序遍历__：左-右-根  下示例：edgfbca  

* * *
         a
        / \
       b   c
     /  \
    d    f
    \   / 
     e g
     
    前序遍历：abdefgc
    中序遍历：debgfac
    后序遍历：edgfbca

####21.设计模式：
 > 
 * __创建型模__式：抽象了类的实例化过程，帮助系统如何创建、组合、表示那些对象
   * 工厂模式(FACTORY)、生成器模式(BUILDER)、工厂方法模式(FACTORY METHOD)、原型模式(PROTOTYPE)、单例模式(SINGLETON)
 * __行为型模式__：解决类实体之间的通讯关系，描述一个控制流程
   * 职责链模式(CHAIN OF RESPONSIBLEITY)、命令模式(COMMAND)、解释器模式(INTERPRETER)、迭代器模式(ITERATOR)、中介者模式(MEDIATOR)、备忘录模式(MEMENTO)、观察者模式(OBSERVER)、状态模式(STATE)、策略模式(STRATEGY)、模板方法模式(TEMPLATE METHOD)、访问者模式(VISITOR)
 * __结构型模式__：如何组合类与对象以获得更大的结构，采用继承机制组合接口与实现
   * 适配器模式(ADAPTER)、桥接模式(BRIDGE)、合成模式(COMPOSITE)、装饰者模式(DECORATOR)、外观模式(FACADOR)、享元模式(FLYWEIGHT)、代理模式(PROXY)
   
####22.关系数据库设计范式：
 >
 * 第一范式(1NF):确保数据库列中的值不重复（实体中的某个属性不能有重复值或者不能有重复的属性）
 * 第二范式(2NF):要求数据库表中的每个行必须可以被唯一的区分，为实现区分通常将表的一个或者多个属性作为行的唯一标识，该标识称之为主键
 * 第三范式(3NF):要求数据库中的表的非主键列之间不能有依赖
 
####23.数据库事务4个特性：
 >
 * __原子性__：事务是一个逻辑工作单位，要么全部执行，要么全部不执行
 * __一致性__：指事务执行的结果从一个一致性状态到另一个一致性状态，
 * __隔离性__：事务之间不能互相干扰
 * __持续性__：事务一旦提交，对数据库中的数据修改是永久性的
 
####24.进程与线程：
 >
 * 资源分配的最小单位是进程，应用程序的运行实例，运营程序的一个动态实例，由进程控制块、程序段、数据段3部分组成，
 * 系统调度的基本单位是线程，是进程的一个实体，不拥有系统资源，与其他线程共享同一个进程的资源，多线程之间并发执行
 
####25.操作系统调度算法：
 >
 * __先来先服务算法(FCFS)__：按作业到达先后顺序
 * __最短作业优先算法(SJF)__：减少平均周转时间，对预计执行时间短的作业先调度，后来的短作业不抢先正在执行的作业
 * __最高响应比优先算法(HRN)__：同时综合FCFS和SJF算法，同时考虑每个作业等待时间和执行时间的长短，从中选出响应比高的作业
 * __基于优先数调度算法(HPF)__：按照优先级高低调度

###26.makefile编写：
     makedir mf
     cd mf
     vim makefile.mk
     hello.o:hello.c hello.h
       gcc -c hello.o -Lm
     make  
     ./hello     
     
     预处理-----> 编译 ----> 汇编 ----> 链接 
     #gcc -E hello.c -o hello.i
     #gcc –S hello.i –o hello.s 
     #gcc –c hello.s –o hello.o 
     #gcc hello.o –o hello.exe 
     #./hello.exe

