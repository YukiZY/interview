##海量数据处理基本数据结构：
所谓海量数据处理，就是指基于海量数据的查找，排序等操作，所谓海量就是指无法一次性装载入内存或者无法短时间内计算出结果，其实就是时间和空间的限制。  

针对空间，可以通过大而化小，分治处理  
针对时间，则通过优秀的数据结构和算法进行化解，数据结构可以采用__Hash/堆/bit_map/数据库/二叉树等__，针对算法可以采用优秀的排序和查找算法，
如__堆排序/快排/归并排序/二分查找等__.

因为set/map/multiset/multimap都是基于RB-tree之上，所以有自动排序功能，而hash_set/hash_map/hash_multiset/hash_multimap都是基于hashtable之上，
所以不含有自动排序功能，至于加个前缀multi_无非就是允许键值重复而已

##海量数据处理基本思想：

###1.分而治之/hash映射 + hash统计 + 堆排/快排/归并排
 + 分而治之/hash映射：数据太大，内存受限，把大文件取模映射成小文件，可以将相同元素映射到同一个文件中，保证同一个数据在一个文件中，不会散列。
 + hash统计：拆分成小文件之后就可以采用hash_map等常规方法进行概率统计
 + 排序：统计完频率之后，就可以采用不同的排序方法进行频率排序。

试题例子：
####1. **给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？**
> 
 可以估计每个文件的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。
 
+ 遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为,这里漏写个了a1）中。这样每个小文件的大约为300M。

+ 遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。

+ 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

