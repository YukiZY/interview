##海量数据处理基本数据结构：
所谓海量数据处理，就是指基于海量数据的查找，排序等操作，所谓海量就是指无法一次性装载入内存或者无法短时间内计算出结果，其实就是时间和空间的限制。  

针对空间，可以通过大而化小，分治处理  
针对时间，则通过优秀的数据结构和算法进行化解，数据结构可以采用__Hash/堆/bit_map/数据库/二叉树等__，针对算法可以采用优秀的排序和查找算法，
如__堆排序/快排/归并排序/二分查找等__.

因为set/map/multiset/multimap都是基于RB-tree之上，所以有自动排序功能，而hash_set/hash_map/hash_multiset/hash_multimap都是基于hashtable之上，
所以不含有自动排序功能，至于加个前缀multi_无非就是允许键值重复而已

##海量数据处理基本思想：

###1.分而治之/hash映射 + hash统计 + 堆排/快排/归并排
 + 分而治之/hash映射：数据太大，内存受限，把大文件取模映射成小文件，可以将相同元素映射到同一个文件中，保证同一个数据在一个文件中，不会散列。
 + hash统计：拆分成小文件之后就可以采用hash_map等常规方法进行概率统计
 + 排序：统计完频率之后，就可以采用不同的排序方法进行频率排序。

试题例子：
####**1.给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？**
> 
 可以估计每个文件的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。
 
+ 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为[a0,a1...a999]）中。这样每个小文件的大约为300M。

+ 遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为[b0,b1...b999]）。这样处理后，所有可能相同的url都在对应的小文件（[a0 VS b0, a1 VS b1...a999 VS b999]）中，因为采用的是相同的hash算法，因此不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。

+ 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

####**2.有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。**

+ 顺序读取10个文件，按照hash(query)%10的结果将query写入到10个文件（记为a0,a1...a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机）。 

+ 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（b0,b1...b9）。 

+ 对这10个文件进行归并排序（内排序与外排序相结合）。

> 
 另一种解法：一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了
 
####**3.有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。**

+ 顺序读文件中，对于每个词x，取，然后按照该值存到5000个小文件（记为a0,a1...a4999）中。这样每个文件大概是200k左右。

+ 如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。

+ 对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件。

+ 下一步就是把这5000个文件进行归并（类似与归并排序）的过程了

####**4.海量日志数据，提取出某日访问百度次数最多的那个IP。**

+ 首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有2^32个IP。 

+ 同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。

+ 然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求

####**5.在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数**

+ 采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32*2bit=1GB内存，还可以接受。

+ 然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。

+ 所描完事后，查看bitmap，把对应位是01的整数输出即可。

>
 方案2：也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。
 
####**6.海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。**

+ 在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆）。 

+ 比如求TOP10大，我们首先取前10个元素调整成最小堆，扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。
 最后堆中的元素就是TOP10大。

+ 求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。

####**7.怎么在海量数据中找出重复次数最多的一个？**

+ 先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求

####**8.上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据**

+ 上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第6题提到的堆机制完成

####**9. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？**

####**10.一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析**

+ 这题是考虑时间效率。用hash_map统计每个词出现的次数，时间复杂度是O(n)。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n)与O(n*lg10)中较大的哪一个

####**11.一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解**
 
+ 首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。

####**12.100w个数中找出最大的100个数**

+ 方案1：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。 

+ 方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。

+ 方案3：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)

####**13.寻找热门查询**

####**14.一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数中的中数？**


